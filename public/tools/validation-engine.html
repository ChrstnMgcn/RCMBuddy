<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Validate - MirraBuddy</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- XLSX library for client-side Excel file parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
        }
        /* Loader Animation - specific CSS needed for animation */
        .loader {
            border: 6px solid #e9ecef;
            border-top: 6px solid #2D62B3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            display: none; /* Hidden by default */
            margin: 25px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Specific print styles to hide UI elements */
        @media print {
            body { background-color: #fff; }
            body * { visibility: hidden; }
            #summaryReportContainer, #summaryReportContainer * { visibility: visible; }
            #summaryReportContainer { position: absolute; left: 0; top: 0; width: 100%; border: none !important; box-shadow: none !important; margin:0 !important; padding:0 !important; border-radius: 0; }
            .print-hidden { display: none !important; } /* Class to hide elements specifically when printing */
            #summaryReportContainer h1, #summaryReportContainer h2, #summaryReportContainer h3, #summaryReportContainer h4 { color: black !important; border: none !important; }
            #summaryReportContainer table, #summaryReportContainer th, #summaryReportContainer td { border: 1px solid #666 !important; }
            #summaryReportContainer th { background-color: #eee !important; }
            a { text-decoration: none; color: black !important; }
            .pass-status { color: #006400 !important; }
            .fail-status { color: #8B0000 !important; }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen text-gray-800">
    <!-- Header Section: Consistent navigation across the app -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 p-4 shadow-lg print-hidden">
        <div class="container mx-auto flex flex-col sm:flex-row items-center justify-between">
            <h1 class="text-white text-3xl font-bold mb-2 sm:mb-0">Excel Validate</h1>
            <nav>
                <ul class="flex space-x-4">
                    <li><a href="/dashboard.html" class="text-white hover:text-blue-200 transition duration-300">Dashboard</a></li>
                    <li><a href="/tools.html" class="text-white hover:text-blue-200 transition duration-300">Tools List</a></li>
                    <li><a href="/tools/data-cleaner.html" class="text-white hover:text-blue-200 transition duration-300">Data Cleaner</a></li>
                    <li><a href="/tools/validation-engine.html" class="text-white hover:text-blue-200 transition duration-300 active">Excel Validate</a></li>
                    <li><a href="#" id="profileLink" class="text-white hover:text-blue-200 transition duration-300">Profile</a></li>
                    <li><a href="#" id="logoutBtn" class="text-white hover:text-blue-200 transition duration-300 cursor-pointer">Logout</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content Section: Central area for the tool's functionality -->
    <main class="flex-grow container mx-auto p-4 sm:p-6 lg:p-8">
        <section class="bg-white p-6 sm:p-8 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl sm:text-3xl font-semibold text-center text-blue-700 mb-4">
                Validate Your Excel Data Against Custom Rules
            </h2>
            <p class="text-lg text-gray-700 text-center mb-6">
                Ensure the integrity and accuracy of your spreadsheets by setting up and running powerful validation rules.
            </p>
            <div class="max-w-xl mx-auto text-gray-600 text-base mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
                <p class="font-semibold text-gray-800 mb-2">About This Tool:</p>
                <p>The **Validation Engine** helps you define and enforce data quality standards for your Excel files. It performs a comprehensive analysis of your data to identify common issues such as blank cells, "NULL" string entries, and dates that fall in the future. Additionally, it identifies duplicate rows within your sheets, ensuring data uniqueness. You can selectively ignore ("override") specific column issues from the overall Pass/Fail calculation in the summary report. This tool is ideal for pre-processing data for analysis, reporting, or database imports, ensuring your datasets are clean and reliable.</p>
                <ul class="list-disc list-inside mt-3 ml-5">
                    <li>**Blank Cells:** Detects and counts empty cells.</li>
                    <li>**"NULL" Strings:** Flags cells containing the literal string "NULL" (case-insensitive).</li>
                    <li>**Future Dates:** Identifies dates that are set after today's date.</li>
                    <li>**Duplicate Rows:** Pinpoints entire rows that are identical, indicating redundant entries.</li>
                    <li>**Override Issues:** Allows you to exclude specific column issues from the final data quality score if they are intentional.</li>
                </ul>
                <p class="mt-3">Upload your file, review the real-time analysis results, override irrelevant issues, and generate a detailed summary report. You can then print the report or export it along with your original data to a new Excel file.</p>
            </div>

            <div class="max-w-xl mx-auto bg-green-50 p-6 rounded-lg shadow-md border border-green-200">
                <h3 class="text-xl font-bold text-green-600 mb-4">Upload File & Analyze</h3>
                <form id="analyzeForm" class="space-y-4">
                    <div>
                        <label for="excelFile" class="block text-sm font-medium text-gray-700">Select Excel or CSV File to Validate</label>
                        <input type="file" id="excelFile" accept=".xlsx, .xls, .csv" required
                               class="mt-1 block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-white focus:outline-none focus:border-green-500">
                    </div>

                    {/* NEW: Data Dictionary Selection */}
                    <div class="border-t border-gray-200 pt-4">
                        <h4 class="text-lg font-bold text-gray-700 mb-2">Optional: Select a Data Dictionary</h4>
                        <p class="text-sm text-gray-600 mb-3">Choose an uploaded data dictionary to use its rules for validation.</p>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <select id="dataDictionarySelect" class="flex-grow p-2 border border-gray-300 rounded-lg bg-white focus:ring-blue-500 focus:border-blue-500">
                                <option value="">-- No Data Dictionary Selected --</option>
                                {/* Options will be loaded here by JavaScript */}
                            </select>
                            <button type="button" id="loadDataDictionaryBtn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm transition duration-300">Load Dictionary</button>
                        </div>
                        <div id="dataDictionaryStatus" class="mt-2 text-sm text-gray-600 hidden"></div>
                    </div>
                    {/* End NEW: Data Dictionary Selection */}

                    <button type="button" id="analyzeFileBtn" onclick="analyzeFile()"
                            class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-lg text-lg font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-300 ease-in-out transform hover:-translate-y-0.5">
                        Analyze File
                    </button>
                </form>

                <div class="loader" id="loader"></div>

                <div id="results" class="mt-8 hidden">
                    <h2 class="text-xl font-bold text-gray-800 mb-4">Analysis Results</h2>
                    <p id="fileName" class="text-gray-700 font-medium mb-4"></p>
                    <div id="overallCounts" class="bg-gray-100 p-4 rounded-lg shadow-inner mb-6">
                        <p id="totalBlankCellsDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalNullCountDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalFutureDatesDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalDuplicateRowsDisplay" class="text-gray-800 text-base font-medium"></p>
                    </div>
                    <div id="sheetResults"></div>
                    <button id="generateSummaryBtn" onclick="generateSummaryReport()" class="mt-6 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition duration-300 hidden">View Summary Report</button>
                </div>
            </div>

            <div id="summaryReportContainer" class="content-box mt-8" style="display:none;">
            </div>
        </section>
    </main>

    <!-- Footer Section -->
    <footer class="bg-gray-800 text-white p-4 mt-8 print-hidden">
        <div class="container mx-auto text-center text-sm">
            &copy; 2025 Excel Buddy. All rights reserved.
        </div>
    </footer>

    <script>
        // --- Authentication Check and Logout Functionality (Adapted for consistency with existing project) ---
        document.addEventListener('DOMContentLoaded', async () => {
            const token = localStorage.getItem('jwtToken');
            if (!token) {
                window.location.href = '/'; // Redirects to index.html
                return;
            }
            try {
                const response = await fetch('/api/protected', {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) {
                    localStorage.removeItem('jwtToken');
                    window.location.href = '/';
                } else {
                    updateDynamicDateDisplay();
                    loadDataDictionaries(); // NEW: Load data dictionaries on page load
                }
            } catch (error) {
                console.error('Error verifying token on Validation Engine page:', error);
                localStorage.removeItem('jwtToken');
                window.location.href = '/';
            }
            // updateDynamicDateDisplay(); // Moved inside successful auth block
        });

        const logoutButton = document.getElementById('logoutBtn');
        if (logoutButton) {
            logoutButton.addEventListener('click', function() {
                localStorage.removeItem('jwtToken');
                window.location.href = '/';
            });
        }
        // --- End of Authentication consistency adaptation ---


        let workbookData = {}; // Stores all parsed data and analysis results
        let originalExcelWorkbook = null; // Stores the original XLSX.js workbook object
        let currentFileName = "ReviewedData.xlsx"; // Default filename for export
        // Overall statistics, dynamically updated based on user overrides
        let overallStats = { blankCells: 0, nullValues: 0, futureDates: 0, duplicateRowCount: 0, totalProcessedDataCells: 0, totalRowsProcessedForDuplicates: 0 };
        const TODAY = new Date();
        TODAY.setUTCHours(0, 0, 0, 0); // Normalize today's date to UTC midnight for consistent date comparisons
        const CLEAN_RATE_PASS_THRESHOLD = 95; // Threshold for "Pass" status in clean rate
        let hasDingedForHighPercentageCurrentFile = false; // Flag to prevent repeated speech notifications
        let loadedDataDictionary = null; // NEW: To store the content of the loaded data dictionary

        // --- NEW DOM Elements for Data Dictionary Selection ---
        const dataDictionarySelect = document.getElementById('dataDictionarySelect');
        const loadDataDictionaryBtn = document.getElementById('loadDataDictionaryBtn');
        const dataDictionaryStatus = document.getElementById('dataDictionaryStatus');

        /**
         * Loads data dictionary files from the backend and populates the dropdown.
         */
        async function loadDataDictionaries() {
            dataDictionarySelect.innerHTML = '<option value="">-- Loading Dictionaries... --</option>';
            const token = localStorage.getItem('jwtToken');
            if (!token) {
                dataDictionarySelect.innerHTML = '<option value="">-- Login to Load Dictionaries --</option>';
                return;
            }

            try {
                const response = await fetch('/api/list-files?isDataDictionary=true', { // NEW: Fetch only data dictionaries
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json();

                if (response.ok && result.files) {
                    dataDictionarySelect.innerHTML = '<option value="">-- No Data Dictionary Selected --</option>'; // Reset
                    result.files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file.id; // Use file ID as value
                        option.textContent = file.filename;
                        dataDictionarySelect.appendChild(option);
                    });
                    if (result.files.length > 0) {
                        dataDictionaryStatus.textContent = `Loaded ${result.files.length} dictionaries.`;
                        dataDictionaryStatus.classList.remove('hidden', 'text-red-600');
                        dataDictionaryStatus.classList.add('text-green-600');
                    } else {
                        dataDictionaryStatus.textContent = `No data dictionaries uploaded for your company.`;
                        dataDictionaryStatus.classList.remove('hidden', 'text-green-600');
                        dataDictionaryStatus.classList.add('text-gray-600');
                    }
                } else {
                    dataDictionarySelect.innerHTML = '<option value="">-- Error Loading Dictionaries --</option>';
                    dataDictionaryStatus.textContent = `Error loading dictionaries: ${result.message || 'Unknown error'}`;
                    dataDictionaryStatus.classList.remove('hidden', 'text-green-600');
                    dataDictionaryStatus.classList.add('text-red-600');
                    console.error('Error loading data dictionaries:', result.error || result.message);
                }
            } catch (error) {
                dataDictionarySelect.innerHTML = '<option value="">-- Network Error --</option>';
                dataDictionaryStatus.textContent = `Network error loading dictionaries: ${error.message}`;
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600');
                dataDictionaryStatus.classList.add('text-red-600');
                console.error('Network error loading data dictionaries:', error);
            }
        }

        /**
         * Event listener for loading a selected data dictionary.
         */
        loadDataDictionaryBtn.addEventListener('click', async () => {
            const selectedFileId = dataDictionarySelect.value;
            if (!selectedFileId) {
                dataDictionaryStatus.textContent = 'Please select a dictionary to load.';
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600');
                dataDictionaryStatus.classList.add('text-red-600');
                loadedDataDictionary = null;
                return;
            }

            dataDictionaryStatus.textContent = 'Loading dictionary...';
            dataDictionaryStatus.classList.remove('hidden', 'text-red-600', 'text-green-600');
            dataDictionaryStatus.classList.add('text-gray-600');
            loadDataDictionaryBtn.disabled = true;

            const token = localStorage.getItem('jwtToken');
            if (!token) {
                dataDictionaryStatus.textContent = 'Login required to load dictionary.';
                dataDictionaryStatus.classList.add('text-red-600');
                loadDataDictionaryBtn.disabled = false;
                return;
            }

            try {
                const response = await fetch(`/api/get-file?fileId=${selectedFileId}`, { // Use get-file to retrieve dictionary content
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json();

                if (response.ok) {
                    const binaryString = atob(result.fileData);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const workbook = XLSX.read(bytes, { type: 'array', cellNF: true, cellDates: false });
                    // Store the parsed workbook for later use by analyzeFile
                    loadedDataDictionary = workbook;
                    dataDictionaryStatus.textContent = `Dictionary "${result.filename}" loaded successfully!`;
                    dataDictionaryStatus.classList.remove('text-red-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-green-600');
                } else {
                    dataDictionaryStatus.textContent = `Error loading dictionary: ${result.message || 'Unknown error'}`;
                    dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-red-600');
                    loadedDataDictionary = null;
                    console.error('Error fetching data dictionary:', result.error || result.message);
                }
            } catch (error) {
                dataDictionaryStatus.textContent = `Network error loading dictionary: ${error.message}`;
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                dataDictionaryStatus.classList.add('text-red-600');
                loadedDataDictionary = null;
                console.error('Network error loading data dictionary:', error);
            } finally {
                loadDataDictionaryBtn.disabled = false;
            }
        });

        /**
         * Updates the display element with the current date, used for future date flagging info.
         */
        function updateDynamicDateDisplay() {
            const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
            const dateElement = document.getElementById('dynamicTodayDate');
            if (dateElement) {
                dateElement.textContent = TODAY.toLocaleDateString('en-US', options);
            }
        }

        /**
         * Shows the loading spinner and hides results sections, resetting global state for a new analysis.
         */
        function showLoader() {
            document.getElementById('loader').style.display = 'block';
            document.getElementById('results').style.display = 'none';
            document.getElementById('summaryReportContainer').style.display = 'none';
            document.getElementById('generateSummaryBtn').style.display = 'none';
            document.getElementById('sheetResults').innerHTML = '';
            document.getElementById('fileName').textContent = '';
            
            // Reset all global data and stats for a fresh analysis
            workbookData = {};
            originalExcelWorkbook = null;
            overallStats = { blankCells: 0, nullValues: 0, futureDates: 0, duplicateRowCount: 0, totalProcessedDataCells: 0, totalRowsProcessedForDuplicates: 0 };
            hasDingedForHighPercentageCurrentFile = false;
            updateInitialOverallCountsDisplay(); // Clear display of previous overall counts
        }

        /**
         * Hides the loading spinner.
         */
        function hideLoader() {
            document.getElementById('loader').style.display = 'none';
        }
        
        /**
         * Updates the overall issue counts displayed prominently above the detailed sheet results.
         */
        function updateInitialOverallCountsDisplay() {
            document.getElementById('totalBlankCellsDisplay').textContent = `Overall Total Blank Cells (active): ${overallStats.blankCells}`;
            document.getElementById('totalNullCountDisplay').textContent = `Overall Total "NULL" Cells (active): ${overallStats.nullValues}`;
            document.getElementById('totalFutureDatesDisplay').textContent = `Overall Total Future Dates (active): ${overallStats.futureDates}`;
            document.getElementById('totalDuplicateRowsDisplay').textContent = `Overall Duplicate Rows Found: ${overallStats.duplicateRowCount}`;
        }
        
        /**
         * Renders the detailed analysis results for each worksheet and column into the UI.
         */
        function renderSheetResultsHTML() {
            const sheetResultsDiv = document.getElementById('sheetResults');
            sheetResultsDiv.innerHTML = ''; // Clear any previously rendered results
            
            Object.keys(workbookData).forEach(sheetName => {
                const sheetData = workbookData[sheetName];
                const sheetResultsContainer = document.createElement('div');
                sheetResultsContainer.classList.add('mb-8'); /* Add margin-bottom for spacing between sheets */
                sheetResultsContainer.innerHTML = `<h3 class="text-xl font-bold text-gray-800 mb-3">Sheet: ${sheetName}</h3>`; /* Styled heading */
                const columnsListUL = document.createElement('ul');
                columnsListUL.classList.add('space-y-4'); /* Add space between column list items */

                // Iterate through columns to render their specific issues and controls
                if (sheetData.columns && Object.keys(sheetData.columns).length > 0) {
                    Object.keys(sheetData.columns).forEach(columnName => {
                        const stats = sheetData.columns[columnName];
                        const listItem = document.createElement('li');
                        listItem.classList.add('p-3', 'bg-gray-50', 'rounded-lg', 'shadow-sm', 'border', 'border-gray-200'); /* Card-like style for each column */
                        
                        let issueDescriptions = [];
                        if (stats.blankCount > 0) issueDescriptions.push("blanks");
                        if (stats.nullStringCount > 0) issueDescriptions.push("NULLs");
                        if (stats.futureDateCount > 0) issueDescriptions.push("future dates");
                        
                        // Construct the descriptive text for column issues
                        let issueTextHTML = issueDescriptions.length > 0 ?
                            `<span class="text-red-600 font-semibold">Column "<strong>${columnName}</strong>" contains: ${issueDescriptions.join(', ')}.</span>` :
                            `<span class="text-green-600 font-semibold">Column "<strong>${columnName}</strong>" is clean.</span>`;
                        
                        // Sanitize column name for use in HTML IDs and data attributes (important for valid HTML)
                        const safeColumnName = columnName.replace(/[^a-zA-Z0-9]/g, "_");
                        const overrideCheckboxId = `override-${sheetName.replace(/[^a-zA-Z0-9]/g, "_")}-${safeColumnName}`;
                        
                        // Display individual issue counts (e.g., Blank=5 | NULL=2)
                        let countsDisplayParts = [];
                        if (stats.blankCount > 0) countsDisplayParts.push(`Blank=${stats.blankCount}`);
                        if (stats.nullStringCount > 0) countsDisplayParts.push(`NULL=${stats.nullStringCount}`);
                        if (stats.futureDateCount > 0) countsDisplayParts.push(`FutureDates=${stats.futureDateCount}`);
                        const countsDisplayHTML = countsDisplayParts.join(' | ');

                        // Build the HTML for each column's summary, including override checkbox and show/hide values button
                        listItem.innerHTML = `
                            <div class="flex flex-col md:flex-row md:items-center justify-between column-summary ${stats.isOverridden ? 'opacity-50 line-through' : ''}">
                                <div class="flex items-center mb-2 md:mb-0">
                                    <input type="checkbox" id="${overrideCheckboxId}" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 mr-2 override-checkbox" data-sheet="${sheetName}" data-column="${safeColumnName}" ${stats.isOverridden ? 'checked' : ''}>
                                    <label for="${overrideCheckboxId}" class="text-sm text-gray-700 mr-4">Override Issues</label>
                                    <span class="text-gray-900 text-base font-medium">${issueTextHTML}</span>
                                </div>
                                <div class="text-sm text-gray-600 italic">${countsDisplayHTML}</div>
                                <button class="ml-auto px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-md text-sm font-medium toggle-values-btn" data-sheet="${sheetName}" data-column="${safeColumnName}">Show Values</button>
                            </div>
                            <div class="column-values-container p-3 mt-3 bg-white border border-gray-300 rounded-lg shadow-inner" style="display:none; max-height: 250px; overflow-y: auto;"></div>
                        `;
                        columnsListUL.appendChild(listItem);
                    });
                } else {
                    const emptyColMsg = document.createElement('li');
                    emptyColMsg.textContent = "No columns found or processed for this sheet.";
                    emptyColMsg.classList.add('p-3', 'bg-gray-50', 'rounded-lg', 'text-gray-600');
                    columnsListUL.appendChild(emptyColMsg);
                }
                sheetResultsContainer.appendChild(columnsListUL);

                if (sheetData.duplicateInfo && sheetData.duplicateInfo.count > 0) {
                    const dupeInfoP = document.createElement('p');
                    dupeInfoP.classList.add('mt-4', 'text-gray-700', 'font-medium', 'text-center');
                    dupeInfoP.innerHTML = `<strong>Duplicate Rows Found in this sheet: ${sheetData.duplicateInfo.count}</strong> (see summary report for details)`;
                    sheetResultsContainer.appendChild(dupeInfoP);
                }
                sheetResultsDiv.appendChild(sheetResultsContainer);
            });
        }

        /**
         * Main function to analyze the uploaded Excel/CSV file.
         * It reads the file, parses it using XLSX.js, and detects various data quality issues.
         */
        function analyzeFile() {
            const fileInput = document.getElementById('excelFile');
            if (fileInput.files.length === 0) {
                alert("Please select a file first.");
                return;
            }
            showLoader(); // Show loader and reset UI before processing
            const file = fileInput.files[0];
            currentFileName = file.name.replace(/\.(xlsx|xls|csv)$/i, '') + "_Reviewed.xlsx"; // Generate a name for the exported file
            document.getElementById('fileName').textContent = `File: ${file.name}`; // Display uploaded file name

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = new Uint8Array(event.target.result);
                    // Read Excel workbook using XLSX.js from ArrayBuffer
                    originalExcelWorkbook = XLSX.read(data, { type: 'array', cellNF: true, cellDates: false });
                    
                    document.getElementById('results').style.display = 'block'; // Show analysis results section
                    
                    overallStats.totalProcessedDataCells = 0; // Reset overall stats
                    overallStats.totalRowsProcessedForDuplicates = 0;

                    // Iterate through each sheet in the workbook
                    originalExcelWorkbook.SheetNames.forEach(sheetName => {
                        const worksheet = originalExcelWorkbook.Sheets[sheetName];
                        // Initialize data structure for the current sheet
                        workbookData[sheetName] = { columns: {}, duplicateInfo: { count: 0, rows: [] } };
                        
                        // Convert sheet to JSON array of arrays for easier processing, especially for duplicates
                        const jsonDataForDuplicates = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                        
                        // --- Duplicate Row Detection Logic ---
                        if (jsonDataForDuplicates.length > 0 || worksheet['!ref']) { // Check if sheet has data or is referenced
                            const seenRowStrings = new Map(); // To track seen row content
                            if (jsonDataForDuplicates.length > 1) { // Ensure there are data rows beyond header
                                overallStats.totalRowsProcessedForDuplicates += (jsonDataForDuplicates.length - 1); // Count data rows
                                for (let i = 1; i < jsonDataForDuplicates.length; i++) { // Iterate from the second row (assuming first is header)
                                    const currentRowData = jsonDataForDuplicates[i];
                                    // Create a consistent string representation of the row for uniqueness check (trim spaces, handle nulls)
                                    const rowString = currentRowData ? currentRowData.map(cell => cell === null || cell === undefined ? "" : String(cell).trim()).join('~!~') : null;
                                    
                                    if (rowString !== null) { // Only process if row has content
                                        if (seenRowStrings.has(rowString)) { // If this row content has been seen before
                                            const firstSeenJsonIndex = seenRowStrings.get(rowString);
                                            // Check if this exact duplicate instance is already recorded
                                            const alreadyRecorded = workbookData[sheetName].duplicateInfo.rows.some(r => r.originalRowIndex === (i + 1) && !r.isFirstOccurrence);
                                            
                                            if (!alreadyRecorded) {
                                                workbookData[sheetName].duplicateInfo.count++; // Increment sheet-specific duplicate count
                                                overallStats.duplicateRowCount++; // Increment global duplicate count
                                                workbookData[sheetName].duplicateInfo.rows.push({
                                                    originalRowIndex: i + 1, // Store Excel row number (1-indexed)
                                                    isFirstOccurrence: false,
                                                    duplicateOf: firstSeenJsonIndex + 1, // Row number of its first occurrence
                                                    data: currentRowData // Store raw row data for sample display in report
                                                });
                                                // Also ensure the *first* occurrence of this duplicate set is recorded
                                                if (!workbookData[sheetName].duplicateInfo.rows.find(r => r.originalRowIndex === (firstSeenJsonIndex + 1))) {
                                                    workbookData[sheetName].duplicateInfo.rows.push({
                                                        originalRowIndex: firstSeenJsonIndex + 1,
                                                        isFirstOccurrence: true,
                                                        duplicateOf: null,
                                                        data: jsonDataForDuplicates[firstSeenJsonIndex]
                                                    });
                                                }
                                            }
                                        } else {
                                            seenRowStrings.set(rowString, i); // Record index of first occurrence
                                        }
                                    }
                                }
                            }
                        }

                        // --- Column-level Issue Detection (Blanks, "NULL" strings, Future Dates) ---
                        const headers = jsonDataForDuplicates[0] || []; // Get headers (first row data)
                        const sheetColumnStats = {};
                        const range = XLSX.utils.decode_range(worksheet['!ref'] || "A1:A1"); // Get actual used range of sheet (e.g., A1:C5)
                        // Determine the maximum number of columns to iterate through based on headers or actual range
                        const maxCols = (headers.length > 0) ? headers.length : (range.e.c + 1);

                        // Initialize stats for each detected column
                        for (let C = 0; C < maxCols; C++) {
                            const columnName = (headers[C] !== null && headers[C] !== undefined) ? String(headers[C]) : `Column ${XLSX.utils.encode_col(C)}`; // Default to "Column A", "Column B" etc.
                            sheetColumnStats[columnName] = { blankCount: 0, nullStringCount: 0, futureDateCount: 0, hasIssue: false, values: [], isOverridden: false };
                        }
                        
                        const actualHeaderKeys = Object.keys(sheetColumnStats); // Get actual column names for iteration

                        // Calculate total processed cells for overall clean rate (excluding header row)
                        if (range.e.r >= range.s.r + 1 && actualHeaderKeys.length > 0) {
                            overallStats.totalProcessedDataCells += (range.e.r - range.s.r) * actualHeaderKeys.length;
                        }

                        // Iterate through cells of the current sheet and collect stats
                        for (let R = range.s.r + 1; R <= range.e.r; ++R) { // Start from the second row (data rows)
                            for (let C = range.s.c; C <= Math.min(range.e.c, maxCols - 1); ++C) { // Iterate up to the determined maxCols
                                const cellAddress = XLSX.utils.encode_cell({ r: R, c: C }); // Get Excel cell address (e.g., A2, B5)
                                const cell = worksheet[cellAddress]; // Get cell object from worksheet
                                let cellValueToStore = cell ? cell.v : null; // Raw value from XLSX.js cell object
                                let processedCellValue = cellValueToStore; // Value potentially processed for type (e.g., Date object)
                                const columnName = actualHeaderKeys[C]; // Get the column's header name

                                if (!columnName) continue;

                                // Special handling for dates to convert Excel's numeric date to JavaScript Date object
                                if (cell && cell.t === 'n' && cell.z && XLSX.SSF.is_date(cell.z)) {
                                    const dateInfo = XLSX.SSF.parse_date_code(cell.v);
                                    if (dateInfo) {
                                        // Create UTC Date object to avoid timezone issues during comparison
                                        processedCellValue = new Date(Date.UTC(dateInfo.y, dateInfo.m - 1, dateInfo.d, dateInfo.H || 0, dateInfo.M || 0, dateInfo.S || 0));
                                        cellValueToStore = processedCellValue;
                                    } else {
                                        processedCellValue = cell.v;
                                    }
                                }

                                // Store the value along with its original row number for display
                                sheetColumnStats[columnName].values.push({ value: cellValueToStore, originalDataRow: R });

                                // Perform issue checks
                                if (processedCellValue instanceof Date && !isNaN(processedCellValue.getTime())) {
                                    // Normalize cell date to UTC midnight for comparison with TODAY
                                    const cellDateOnly = new Date(Date.UTC(processedCellValue.getUTCFullYear(), processedCellValue.getUTCMonth(), processedCellValue.getUTCDate()));
                                    if (cellDateOnly > TODAY) { // Check if date is in the future
                                        sheetColumnStats[columnName].futureDateCount++;
                                        sheetColumnStats[columnName].hasIssue = true;
                                    }
                                } else if (processedCellValue !== null && processedCellValue !== undefined && String(processedCellValue).trim().toUpperCase() === "NULL") {
                                    // Check for the string "NULL" (case-insensitive, trimmed)
                                    sheetColumnStats[columnName].nullStringCount++;
                                    sheetColumnStats[columnName].hasIssue = true;
                                } else if (processedCellValue === null || String(processedCellValue).trim() === "") {
                                    // Check for truly blank cells (null or empty string after trimming)
                                    sheetColumnStats[columnName].blankCount++;
                                    sheetColumnStats[columnName].hasIssue = true;
                                }
                            }
                        }
                        workbookData[sheetName].columns = sheetColumnStats; // Store collected column stats
                    });
                    
                    recalculateGlobalOverallStatsFromWorkbookData(); // Update global stats based on all sheets
                    renderSheetResultsHTML(); // Render the initial analysis results in the UI
                    updateInitialOverallCountsDisplay(); // Update the prominent overall counts
                    document.getElementById('generateSummaryBtn').style.display = 'inline-block'; // Show the "View Summary Report" button
                } catch (error) {
                    console.error("Error processing file:", error);
                    document.getElementById('sheetResults').innerHTML = `<p class="text-red-600">Error processing file: ${error.message}. Make sure it's a valid Excel/CSV file.</p>`;
                    updateInitialOverallCountsDisplay();
                } finally {
                    hideLoader();
                }
            };
            reader.readAsArrayBuffer(file); // Start reading the file as an ArrayBuffer
        }
        
        /**
         * Generates and displays the comprehensive summary report in a separate section.
         * This report is also the basis for the Excel export.
         * @param {boolean} shouldScrollToReport - If true, the page will scroll to the report section.
         */
        function generateSummaryReport(shouldScrollToReport = true) {
            const summaryContainer = document.getElementById('summaryReportContainer');
            summaryContainer.innerHTML = ''; // Clear previous report content
            recalculateGlobalOverallStatsFromWorkbookData(); // Ensure global stats are up-to-date with overrides

            // Calculate overall data quality metrics
            const totalCellLevelIssues = overallStats.blankCells + overallStats.nullValues + overallStats.futureDates;
            const totalEffectiveIssues = totalCellLevelIssues + overallStats.duplicateRowCount;
            // Denominator for issue rate, ensuring no division by zero
            const issueRateDenominator = (overallStats.totalProcessedDataCells + overallStats.totalRowsProcessedForDuplicates) || 1;
            const issueRate = (totalEffectiveIssues / issueRateDenominator) * 100;
            const cleanRate = Math.max(0, 100 - issueRate); // Clean rate cannot be negative
            const passFailStatus = cleanRate >= CLEAN_RATE_PASS_THRESHOLD ? "Pass" : "Fail";
            const passFailClass = passFailStatus === "Pass" ? "text-green-600" : "text-red-600";

            // Play a success sound if clean rate meets threshold and hasn't played for this file yet
            if (passFailStatus === "Pass" && !hasDingedForHighPercentageCurrentFile) {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.speak(new SpeechSynthesisUtterance("Validation passed"));
                }
                hasDingedForHighPercentageCurrentFile = true;
            } else if (passFailStatus === "Fail") {
                hasDingedForHighPercentageCurrentFile = false; // Reset flag if validation fails
            }

            // Build the HTML for the overall statistics summary section
            let reportHTML = `<h1 class="text-2xl font-bold text-blue-700 mb-4 text-center">Data Quality Summary Report</h1><div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h2>Overall Statistics (Column Issue Overrides Applied)</h2>`;
            reportHTML += `<p class="text-gray-700"><strong>File:</strong> ${document.getElementById('fileName').textContent.replace('File: ', '')}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Processed Data Cells:</strong> ${overallStats.totalProcessedDataCells}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Rows Processed (for duplicates):</strong> ${overallStats.totalRowsProcessedForDuplicates}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Blank Cells (effective):</strong> ${overallStats.blankCells}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total "NULL" Cells (effective):</p><span>${overallStats.nullValues}</span>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Future Dates (effective):</strong> ${overallStats.futureDates}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Duplicate Rows Found:</strong> ${overallStats.duplicateRowCount}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Cell-Level Issues (effective):</strong> ${totalCellLevelIssues}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Effective Issues (Cells + Duplicates):</strong> ${totalEffectiveIssues}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Issue Rate (approximate):</strong> ${issueRate.toFixed(2)}%</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Clean Rate (approximate):</strong> ${cleanRate.toFixed(2)}%</p>`;
            reportHTML += `<p class="text-lg font-semibold mt-4"><strong>Status: <span class="${passFailClass}">${passFailStatus}</span></strong> (Threshold: ${CLEAN_RATE_PASS_THRESHOLD}% clean)</p></div>`;
            
            reportHTML += `<div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h2>Detailed Issues by Column (Raw Counts)</h2><table class="w-full text-left table-auto border-collapse"><thead><tr class="bg-gray-200"><th>Sheet</th><th>Column</th><th>Blanks</th><th>NULLs</th><th>Future Dates</th><th>Overridden</th></tr></thead><tbody>`;
            
            let issuesFoundDetails = false;
            Object.keys(workbookData).forEach(sheetName => {
                const sheetColData = workbookData[sheetName].columns;
                if (sheetColData) {
                    Object.keys(sheetColData).forEach(columnName => {
                        const stats = sheetColData[columnName];
                        if (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0 || stats.isOverridden) {
                            issuesFoundDetails = true;
                            const safeColName = columnName.replace(/[^a-zA-Z0-9]/g, "_");
                            const overriddenMarker = stats.isOverridden ? ' <span class="text-gray-500 text-xs italic">(Overridden)</span>' : '';
                            const overriddenClass = stats.isOverridden ? 'opacity-50 line-through' : '';
                            reportHTML += `<tr class="border-b border-gray-200"><td>${sheetName}</td><td>${columnName}${overriddenMarker}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="blankCount">${stats.blankCount}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="nullStringCount">${stats.nullStringCount}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="futureDateCount">${stats.futureDateCount}</td><td>${stats.isOverridden ? "Yes" : "No"}</td></tr>`;
                        }
                    });
                }
            });
            if (!issuesFoundDetails) reportHTML += `<tr><td colspan="6" class="text-center text-gray-500 py-4">No specific column issues found or overridden.</td></tr>`;
            reportHTML += `</tbody></table></div>`;

            reportHTML += `<div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h3>Duplicate Row Details</h3><table class="w-full text-left table-auto border-collapse"><thead><tr class="bg-gray-200"><th>Sheet</th><th>Duplicate Row #</th><th>First Seen At Row #</th><th>Sample Data (First 3 Cells)</th></tr></thead><tbody>`;
            
            let duplicatesListed = false;
            Object.keys(workbookData).forEach(sheetName => {
                const { duplicateInfo } = workbookData[sheetName];
                if (duplicateInfo && duplicateInfo.rows) {
                    const sortedDuplicates = [...duplicateInfo.rows].sort((a, b) => {
                        if (a.originalRowIndex !== b.originalRowIndex) {
                            return a.originalRowIndex - b.originalRowIndex;
                        }
                        return a.isFirstOccurrence ? -1 : 1;
                    });

                    sortedDuplicates.forEach(dupeRow => {
                        if (!dupeRow.isFirstOccurrence) {
                            duplicatesListed = true;
                            const sample = dupeRow.data.slice(0, 3).map(d => {
                                if (d === null || d === undefined) return "";
                                if (d instanceof Date) return d.toLocaleDateString('en-US', {timeZone: 'UTC'});
                                return String(d);
                            }).join(', ');
                            reportHTML += `<tr class="border-b border-gray-200"><td>${sheetName}</td><td>${dupeRow.originalRowIndex}</td><td>${dupeRow.duplicateOf}</td><td>${sample}...</td></tr>`;
                        }
                    });
                }
            });
            if (!duplicatesListed) reportHTML += `<tr><td colspan="4" class="text-center text-gray-500 py-4">No duplicate rows found.</td></tr>`;
            reportHTML += `</tbody></table></div>`;

            reportHTML += `<div class="flex justify-center space-x-4 print-hidden">`;
            reportHTML += `<button id="printSummaryBtn" onclick="window.print()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-300">Print Report</button>`;
            reportHTML += `<button id="exportExcelBtn" onclick="exportExcelWithSummary()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-300">Export Excel w/ Summary</button>`;
            reportHTML += `</div>`;
            
            summaryContainer.innerHTML = reportHTML;
            summaryContainer.style.display = 'block';
            if (shouldScrollToReport) summaryContainer.scrollIntoView({ behavior: 'smooth' });
        }

        document.getElementById('sheetResults').addEventListener('click', function(event) {
            const target = event.target;
            if (target.classList.contains('override-checkbox')) {
                const { sheet, column } = target.dataset;
                const originalColName = findOriginalColumnName(sheet, column);
                if (workbookData[sheet]?.columns?.[originalColName]) {
                    workbookData[sheet].columns[originalColName].isOverridden = target.checked;
                    target.closest('.column-summary').classList.toggle('opacity-50', target.checked);
                    target.closest('.column-summary').classList.toggle('line-through', target.checked);
                    recalculateGlobalOverallStatsFromWorkbookData();
                    updateInitialOverallCountsDisplay();
                    if (document.getElementById('summaryReportContainer').style.display !== 'none') {
                        generateSummaryReport(false);
                    }
                }
            } else if (target.classList.contains('toggle-values-btn')) {
                const { sheet, column } = target.dataset;
                const originalColName = findOriginalColumnName(sheet, column);
                const valuesContainer = target.closest('li').querySelector('.column-values-container');
                if (!workbookData[sheet]?.columns?.[originalColName]) {
                    console.error("Data not found for:", sheet, originalColName);
                    return;
                }
                if (valuesContainer.style.display === 'none') {
                    valuesContainer.innerHTML = '';
                    const stats = workbookData[sheet].columns[originalColName];
                    const sortableValues = stats.values.map(item => {
                        const val = item.value;
                        const stringValue = (val === null || val === undefined) ? "" : String(val).trim();
                        const isFuture = (val instanceof Date && !isNaN(val.getTime()) && new Date(Date.UTC(val.getUTCFullYear(), val.getUTCMonth(), val.getUTCDate())) > TODAY);
                        const isBlank = (val === null || stringValue === "");
                        const isNullString = (val !== null && val !== undefined && stringValue.toUpperCase() === "NULL");
                        const isInvalidDate = (val instanceof Date && isNaN(val.getTime()));
                        const hasAnyIssue = isFuture || isBlank || isNullString || isInvalidDate;
                        return { ...item, value: val, isFuture, isBlank, isNullString, isInvalidDate, hasAnyIssue };
                    });
                    sortableValues.sort((a, b) => (a.hasAnyIssue === b.hasAnyIssue) ? a.originalDataRow - b.originalDataRow : a.hasAnyIssue ? -1 : 1);

                    if (sortableValues.length > 0) {
                        const ul = document.createElement('ul');
                        ul.classList.add('space-y-1');
                        sortableValues.forEach(item => {
                            const { value, originalDataRow } = item;
                            const li = document.createElement('li');
                            let displayValue;
                            let valueClass = '';

                            if (item.isFuture) { valueClass = 'text-red-500 font-bold'; displayValue = `Row ${originalDataRow + 1}: Future Date - ${value.toLocaleDateString('en-US', {timeZone: 'UTC'})}`; }
                            else if (item.isBlank) { valueClass = 'text-orange-500 italic'; displayValue = `Row ${originalDataRow + 1}: Blank Cell (${value === null ? 'null' : 'empty string'})`; }
                            else if (item.isNullString) { valueClass = 'text-red-500 italic'; displayValue = `Row ${originalDataRow + 1}: NULL String Issue - "${value}"`; }
                            else if (item.isInvalidDate) { valueClass = 'text-red-500 italic'; displayValue = `Row ${originalDataRow + 1}: Invalid Date Object - "${String(value)}"`; }
                            else if (value instanceof Date) { valueClass = 'text-blue-600'; displayValue = `Row ${originalDataRow + 1}: ${value.toLocaleDateString('en-US', {timeZone: 'UTC'})}`; }
                            else if (typeof value === 'object' && value !== null) { try { displayValue = `Row ${originalDataRow + 1}: Value: ${JSON.stringify(value)}`; } catch (e) { displayValue = `Row ${originalDataRow + 1}: Value: [Object]`; } }
                            else { displayValue = `Row ${originalDataRow + 1}: Value: ${value}`; }

                            li.textContent = displayValue;
                            if (valueClass) li.classList.add(valueClass);
                            else if(item.hasAnyIssue) li.classList.add('text-orange-600', 'font-bold');
                            ul.appendChild(li);
                        });
                        valuesContainer.appendChild(ul);
                    } else {
                        valuesContainer.innerHTML = '<p class="text-gray-500 italic">This column has no data rows.</p>';
                    }
                    valuesContainer.style.display = 'block';
                    target.textContent = 'Hide Values';
                } else {
                    valuesContainer.style.display = 'none';
                    valuesContainer.innerHTML = '';
                    target.textContent = 'Show Values';
                }
            }
        });

        function findOriginalColumnName(sheet, colFromDataset) {
            const cols = workbookData[sheet]?.columns;
            if (!cols) return colFromDataset;
            if (cols[colFromDataset]) return colFromDataset;
            return Object.keys(cols).find(k => k.replace(/[^a-zA-Z0-9]/g, "_") === colFromDataset) || colFromDataset;
        }

        function recalculateGlobalOverallStatsFromWorkbookData() {
            let newBlank = 0, newNull = 0, newFuture = 0;
            Object.values(workbookData).forEach(({ columns }) => {
                if(columns) Object.values(columns).forEach(stats => {
                    if (!stats.isOverridden) {
                        newBlank += parseInt(stats.blankCount, 10) || 0;
                        newNull += parseInt(stats.nullStringCount, 10) || 0;
                        newFuture += parseInt(stats.futureDateCount, 10) || 0;
                    }
                });
            });
            overallStats.blankCells = newBlank;
            overallStats.nullValues = newNull;
            overallStats.futureDates = newFuture;
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('summaryReportContainer')?.addEventListener('blur', function(event) {
                if (event.target.classList.contains('editable-stat')) {
                    const td = event.target;
                    const { sheet, column, type } = td.dataset;
                    const originalColName = findOriginalColumnName(sheet, column);
                    const newValue = parseInt(td.textContent.trim(), 10);

                    if (workbookData[sheet]?.columns?.[originalColName]) {
                        const stats = workbookData[sheet].columns[originalColName];
                        if (isNaN(newValue) || newValue < 0 || td.textContent.trim() === "") {
                            alert("Please enter a valid non-negative number.");
                            td.textContent = stats[type];
                            return;
                        }
                        stats[type] = newValue;
                        stats.hasIssue = (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0); 
                        recalculateGlobalOverallStatsFromWorkbookData();
                        if (document.getElementById('summaryReportContainer').style.display !== 'none') {
                            generateSummaryReport(false);
                        } else {
                            updateInitialOverallCountsDisplay();
                        }
                    } else {
                        console.error("Editable cell event: Could not find column data for update:", sheet, originalColName);
                    }
                }
            }, true);
        });

        function exportExcelWithSummary() {
            if (!originalExcelWorkbook) {
                alert("Please analyze a file first to generate data for export.");
                return;
            }
            recalculateGlobalOverallStatsFromWorkbookData();

            const wb = XLSX.utils.book_new();

            originalExcelWorkbook.SheetNames.forEach(sheetName => {
                const sheetData = XLSX.utils.sheet_to_json(originalExcelWorkbook.Sheets[sheetName], {header:1, defval:null});
                XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(sheetData), sheetName);
            });

            const summaryAoA = [];
            const { blankCells, nullValues, futureDates, duplicateRowCount, totalProcessedDataCells, totalRowsProcessedForDuplicates } = overallStats;
            const totalCellIssues = blankCells + nullValues + futureDates;
            const totalEffectiveIssues = totalCellIssues + duplicateRowCount;
            const denominator = (totalProcessedDataCells + totalRowsProcessedForDuplicates) || 1;
            const issueRate = (totalEffectiveIssues / denominator) * 100;
            const cleanRate = Math.max(0, 100 - issueRate);
            const status = cleanRate >= CLEAN_RATE_PASS_THRESHOLD ? "Pass" : "Fail";

            summaryAoA.push(["Data Quality Summary Report"]);
            summaryAoA.push([]);
            summaryAoA.push(["Overall Statistics"]);
            summaryAoA.push(["File:", document.getElementById('fileName').textContent.replace('File: ', '')]);
            summaryAoA.push(["Total Processed Data Cells:", totalProcessedDataCells]);
            summaryAoA.push(["Total Rows Processed (for duplicates):", totalRowsProcessedForDuplicates]);
            summaryAoA.push(["Total Blank Cells (effective):", blankCells]);
            summaryAoA.push(["Total \"NULL\" Cells (effective):", nullValues]);
            summaryAoA.push(["Total Future Dates (effective):", futureDates]);
            summaryAoA.push(["Total Duplicate Rows Found:", duplicateRowCount]);
            summaryAoA.push(["Total Cell-Level Issues (effective):", totalCellIssues]);
            summaryAoA.push(["Total Effective Issues (Cells + Duplicates):", totalEffectiveIssues]);
            summaryAoA.push(["Issue Rate (approximate):", `${issueRate.toFixed(2)}%`]);
            summaryAoA.push(["Clean Rate (approximate):", `${cleanRate.toFixed(2)}%`]);
            summaryAoA.push(["Status:", `${status} (Threshold: ${CLEAN_RATE_PASS_THRESHOLD}% clean)`]);
            summaryAoA.push([]);

            summaryAoA.push(["Detailed Issues by Column (Raw Counts)"]);
            summaryAoA.push(["Sheet", "Column", "Blanks", "NULLs", "Future Dates", "Overridden"]);
            
            let detailsAdded = false;
            Object.entries(workbookData).forEach(([sheetName, { columns }]) => {
                if (columns) {
                    Object.entries(columns).forEach(([columnName, stats]) => {
                        if (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0 || stats.isOverridden) {
                            detailsAdded = true;
                            summaryAoA.push([sheetName, columnName, stats.blankCount, stats.nullStringCount, stats.futureDateCount, stats.isOverridden ? "Yes" : "No"]);
                        }
                    });
                }
            });
            if (!detailsAdded) summaryAoA.push(["No columns with issues or overrides to report."]);
            summaryAoA.push([]);

            summaryAoA.push(["Duplicate Row Details"]);
            summaryAoA.push(["Sheet", "Duplicate Row #", "First Seen At Row #", "Sample Data (First 3 Cells)"]);
            
            let duplicatesExported = false;
            Object.entries(workbookData).forEach(([sheetName, { duplicateInfo }]) => {
                if (duplicateInfo && duplicateInfo.rows) {
                    const duplicatesToExport = duplicateInfo.rows.filter(dupe => !dupe.isFirstOccurrence).sort((a, b) => a.originalRowIndex - b.originalRowIndex);

                    duplicatesToExport.forEach(dupe => {
                        duplicatesExported = true;
                        const sample = dupe.data.slice(0, 3).map(d => {
                            if (d === null || d === undefined) return "";
                            if (d instanceof Date) return d.toLocaleDateString('en-US', {timeZone: 'UTC'});
                            return String(d);
                        }).join(', ');
                        summaryAoA.push([sheetName, dupe.originalRowIndex, dupe.duplicateOf, `${sample}...`]);
                    });
                }
            });
            if (!duplicatesExported) summaryAoA.push(["No duplicate rows found."]);

            const summaryWS = XLSX.utils.aoa_to_sheet(summaryAoA);
            XLSX.utils.book_append_sheet(wb, summaryWS, "Summary Report");

            XLSX.writeFile(wb, currentFileName);
        }
    </script>
</body>
</html>
```
I understand you've provided the code for the `file-manager-frontend` Canvas and are asking to move to the "next" step. This is a follow-up to the previous context about data dictionaries.

Since `list-files.js` is now returning the `is_data_dictionary` flag and `file-manager.html` has been updated to display it, the logical next step is to **update your `public/tools/validation-engine.html` page**. This update will allow users to select an uploaded data dictionary (from a dropdown) and prepare its contents for use in the validation process.

This is a **client-side integration** step.

Here is the updated code for your `public/tools/validation-engine.html` file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Validate - MirraBuddy</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- XLSX library for client-side Excel file parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
        }
        /* Loader Animation - specific CSS needed for animation */
        .loader {
            border: 6px solid #e9ecef;
            border-top: 6px solid #2D62B3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            display: none; /* Hidden by default */
            margin: 25px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Specific print styles to hide UI elements */
        @media print {
            body { background-color: #fff; }
            body * { visibility: hidden; }
            #summaryReportContainer, #summaryReportContainer * { visibility: visible; }
            #summaryReportContainer { position: absolute; left: 0; top: 0; width: 100%; border: none !important; box-shadow: none !important; margin:0 !important; padding:0 !important; border-radius: 0; }
            .print-hidden { display: none !important; } /* Class to hide elements specifically when printing */
            #summaryReportContainer h1, #summaryReportContainer h2, #summaryReportContainer h3, #summaryReportContainer h4 { color: black !important; border: none !important; }
            #summaryReportContainer table, #summaryReportContainer th, #summaryReportContainer td { border: 1px solid #666 !important; }
            #summaryReportContainer th { background-color: #eee !important; }
            a { text-decoration: none; color: black !important; }
            .pass-status { color: #006400 !important; }
            .fail-status { color: #8B0000 !important; }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen text-gray-800">
    <!-- Header Section: Consistent navigation across the app -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 p-4 shadow-lg print-hidden">
        <div class="container mx-auto flex flex-col sm:flex-row items-center justify-between">
            <h1 class="text-white text-3xl font-bold mb-2 sm:mb-0">Excel Validate</h1>
            <nav>
                <ul class="flex space-x-4">
                    <li><a href="/dashboard.html" class="text-white hover:text-blue-200 transition duration-300">Dashboard</a></li>
                    <li><a href="/tools.html" class="text-white hover:text-blue-200 transition duration-300">Tools List</a></li>
                    <li><a href="/tools/data-cleaner.html" class="text-white hover:text-blue-200 transition duration-300">Data Cleaner</a></li>
                    <li><a href="/tools/validation-engine.html" class="text-white hover:text-blue-200 transition duration-300 active">Excel Validate</a></li>
                    <li><a href="#" id="profileLink" class="text-white hover:text-blue-200 transition duration-300">Profile</a></li>
                    <li><a href="#" id="logoutBtn" class="text-white hover:text-blue-200 transition duration-300 cursor-pointer">Logout</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content Section: Central area for the tool's functionality -->
    <main class="flex-grow container mx-auto p-4 sm:p-6 lg:p-8">
        <section class="bg-white p-6 sm:p-8 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl sm:text-3xl font-semibold text-center text-blue-700 mb-4">
                Validate Your Excel Data Against Custom Rules
            </h2>
            <p class="text-lg text-gray-700 text-center mb-6">
                Ensure the integrity and accuracy of your spreadsheets by setting up and running powerful validation rules.
            </p>
            <div class="max-w-xl mx-auto text-gray-600 text-base mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
                <p class="font-semibold text-gray-800 mb-2">About This Tool:</p>
                <p>The **Validation Engine** helps you define and enforce data quality standards for your Excel files. It performs a comprehensive analysis of your data to identify common issues such as blank cells, "NULL" string entries, and dates that fall in the future. Additionally, it identifies duplicate rows within your sheets, ensuring data uniqueness. You can selectively ignore ("override") specific column issues from the overall Pass/Fail calculation in the summary report. This tool is ideal for pre-processing data for analysis, reporting, or database imports, ensuring your datasets are clean and reliable.</p>
                <ul class="list-disc list-inside mt-3 ml-5">
                    <li>**Blank Cells:** Detects and counts empty cells.</li>
                    <li>**"NULL" Strings:** Flags cells containing the literal string "NULL" (case-insensitive).</li>
                    <li>**Future Dates:** Identifies dates that are set after today's date.</li>
                    <li>**Duplicate Rows:** Pinpoints entire rows that are identical, indicating redundant entries.</li>
                    <li>**Override Issues:** Allows you to exclude specific column issues from the final data quality score if they are intentional.</li>
                </ul>
                <p class="mt-3">Upload your file, review the real-time analysis results, override irrelevant issues, and generate a detailed summary report. You can then print the report or export it along with your original data to a new Excel file.</p>
            </div>

            <div class="max-w-xl mx-auto bg-green-50 p-6 rounded-lg shadow-md border border-green-200">
                <h3 class="text-xl font-bold text-green-600 mb-4">Upload File & Analyze</h3>
                <form id="analyzeForm" class="space-y-4">
                    <div>
                        <label for="excelFile" class="block text-sm font-medium text-gray-700">Select Excel or CSV File to Validate</label>
                        <input type="file" id="excelFile" accept=".xlsx, .xls, .csv" required
                               class="mt-1 block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-white focus:outline-none focus:border-green-500">
                    </div>

                    {/* NEW: Data Dictionary Selection */}
                    <div class="border-t border-gray-200 pt-4">
                        <h4 class="text-lg font-bold text-gray-700 mb-2">Optional: Select a Data Dictionary</h4>
                        <p class="text-sm text-gray-600 mb-3">Choose an uploaded data dictionary to use its rules for validation.</p>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <select id="dataDictionarySelect" class="flex-grow p-2 border border-gray-300 rounded-lg bg-white focus:ring-blue-500 focus:border-blue-500">
                                <option value="">-- No Data Dictionary Selected --</option>
                                {/* Options will be loaded here by JavaScript */}
                            </select>
                            <button type="button" id="loadDataDictionaryBtn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm transition duration-300">Load Dictionary</button>
                        </div>
                        <div id="dataDictionaryStatus" class="mt-2 text-sm text-gray-600 hidden"></div>
                    </div>
                    {/* End NEW: Data Dictionary Selection */}

                    <button type="button" id="analyzeFileBtn" onclick="analyzeFile()"
                            class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-lg text-lg font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-300 ease-in-out transform hover:-translate-y-0.5">
                        Analyze File
                    </button>
                </form>

                <div class="loader" id="loader"></div>

                <div id="results" class="mt-8 hidden">
                    <h2 class="text-xl font-bold text-gray-800 mb-4">Analysis Results</h2>
                    <p id="fileName" class="text-gray-700 font-medium mb-4"></p>
                    <div id="overallCounts" class="bg-gray-100 p-4 rounded-lg shadow-inner mb-6">
                        <p id="totalBlankCellsDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalNullCountDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalFutureDatesDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalDuplicateRowsDisplay" class="text-gray-800 text-base font-medium"></p>
                    </div>
                    <div id="sheetResults"></div>
                    <button id="generateSummaryBtn" onclick="generateSummaryReport()" class="mt-6 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition duration-300 hidden">View Summary Report</button>
                </div>
            </div>

            <div id="summaryReportContainer" class="content-box mt-8" style="display:none;">
            </div>
        </section>
    </main>

    <!-- Footer Section -->
    <footer class="bg-gray-800 text-white p-4 mt-8 print-hidden">
        <div class="container mx-auto text-center text-sm">
            &copy; 2025 Excel Buddy. All rights reserved.
        </div>
    </footer>

    <script>
        // --- Authentication Check and Logout Functionality (Adapted for consistency with existing project) ---
        document.addEventListener('DOMContentLoaded', async () => {
            const token = localStorage.getItem('jwtToken');
            if (!token) {
                window.location.href = '/'; // Redirects to index.html
                return;
            }
            try {
                const response = await fetch('/api/protected', {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) {
                    localStorage.removeItem('jwtToken');
                    window.location.href = '/';
                } else {
                    updateDynamicDateDisplay();
                    loadDataDictionaries(); // NEW: Call to load data dictionaries on successful auth
                }
            } catch (error) {
                console.error('Error verifying token on Validation Engine page:', error);
                localStorage.removeItem('jwtToken');
                window.location.href = '/';
            }
            // updateDynamicDateDisplay(); // Moved inside successful auth block
        });

        const logoutButton = document.getElementById('logoutBtn');
        if (logoutButton) {
            logoutButton.addEventListener('click', function() {
                localStorage.removeItem('jwtToken');
                window.location.href = '/';
            });
        }
        // --- End of Authentication consistency adaptation ---


        let workbookData = {}; // Stores all parsed data and analysis results
        let originalExcelWorkbook = null; // Stores the original XLSX.js workbook object
        let currentFileName = "ReviewedData.xlsx"; // Default filename for export
        // Overall statistics, dynamically updated based on user overrides
        let overallStats = { blankCells: 0, nullValues: 0, futureDates: 0, duplicateRowCount: 0, totalProcessedDataCells: 0, totalRowsProcessedForDuplicates: 0 };
        const TODAY = new Date();
        TODAY.setUTCHours(0, 0, 0, 0); // Normalize today's date to UTC midnight for consistent date comparisons
        const CLEAN_RATE_PASS_THRESHOLD = 95; // Threshold for "Pass" status in clean rate
        let hasDingedForHighPercentageCurrentFile = false; // Flag to prevent repeated speech notifications
        let loadedDataDictionary = null; // NEW: To store the content of the loaded data dictionary workbook

        // --- NEW DOM Elements for Data Dictionary Selection ---
        const dataDictionarySelect = document.getElementById('dataDictionarySelect');
        const loadDataDictionaryBtn = document.getElementById('loadDataDictionaryBtn');
        const dataDictionaryStatus = document.getElementById('dataDictionaryStatus');

        /**
         * Loads data dictionary files from the backend (File Manager's list-files endpoint)
         * and populates the dropdown. Filters for files marked as is_data_dictionary.
         */
        async function loadDataDictionaries() {
            dataDictionarySelect.innerHTML = '<option value="">-- Loading Dictionaries... --</option>'; // Initial loading state
            const token = localStorage.getItem('jwtToken');
            if (!token) {
                dataDictionarySelect.innerHTML = '<option value="">-- Login to Load Dictionaries --</option>';
                return;
            }

            try {
                // Fetch files from /api/list-files, specifically asking for data dictionaries
                // This assumes list-files.js can take a query param to filter, or we filter on frontend
                const response = await fetch('/api/list-files', { // Assuming backend will filter if needed, otherwise filter here
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json();

                if (response.ok && result.files) {
                    // Filter files to only include those marked as data dictionaries
                    const dataDictionaries = result.files.filter(file => file.is_data_dictionary);

                    dataDictionarySelect.innerHTML = '<option value="">-- No Data Dictionary Selected --</option>'; // Reset dropdown
                    dataDictionaries.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file.id; // Use file ID as the option value
                        option.textContent = file.filename; // Display filename
                        dataDictionarySelect.appendChild(option);
                    });

                    if (dataDictionaries.length > 0) {
                        dataDictionaryStatus.textContent = `Loaded ${dataDictionaries.length} dictionaries.`;
                        dataDictionaryStatus.classList.remove('hidden', 'text-red-600');
                        dataDictionaryStatus.classList.add('text-green-600');
                    } else {
                        dataDictionaryStatus.textContent = `No data dictionaries uploaded for your company.`;
                        dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-red-600');
                        dataDictionaryStatus.classList.add('text-gray-600');
                    }
                } else {
                    dataDictionarySelect.innerHTML = '<option value="">-- Error Loading Dictionaries --</option>';
                    dataDictionaryStatus.textContent = `Error loading dictionaries: ${result.message || 'Unknown error'}`;
                    dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-red-600');
                    console.error('Error loading data dictionaries:', result.error || result.message);
                }
            } catch (error) {
                dataDictionarySelect.innerHTML = '<option value="">-- Network Error --</option>';
                dataDictionaryStatus.textContent = `Network error loading dictionaries: ${error.message}`;
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                dataDictionaryStatus.classList.add('text-red-600');
                console.error('Network error loading data dictionaries:', error);
            }
        }

        /**
         * Event listener for loading a selected data dictionary's content.
         * Fetches the file data and parses it as an Excel workbook.
         */
        loadDataDictionaryBtn.addEventListener('click', async () => {
            const selectedFileId = dataDictionarySelect.value;
            if (!selectedFileId) {
                dataDictionaryStatus.textContent = 'Please select a dictionary to load.';
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600');
                dataDictionaryStatus.classList.add('text-red-600');
                loadedDataDictionary = null; // Clear any previously loaded dictionary
                return;
            }

            dataDictionaryStatus.textContent = 'Loading dictionary content...';
            dataDictionaryStatus.classList.remove('hidden', 'text-red-600', 'text-green-600');
            dataDictionaryStatus.classList.add('text-gray-600');
            loadDataDictionaryBtn.disabled = true; // Disable button during load

            const token = localStorage.getItem('jwtToken');
            if (!token) {
                dataDictionaryStatus.textContent = 'Login required to load dictionary content.';
                dataDictionaryStatus.classList.add('text-red-600');
                loadDataDictionaryBtn.disabled = false;
                return;
            }

            try {
                // Fetch the binary content of the selected data dictionary file
                const response = await fetch(`/api/get-file?fileId=${selectedFileId}`, { // Use get-file to retrieve dictionary content
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json(); // Expecting JSON with fileData (base64)

                if (response.ok) {
                    // Decode base64 to binary string
                    const binaryString = atob(result.fileData);
                    // Convert binary string to Uint8Array
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    // Parse the binary Excel/CSV data using XLSX.js
                    const workbook = XLSX.read(bytes, { type: 'array', cellNF: true, cellDates: false });
                    
                    // Store the parsed workbook for later use by analyzeFile
                    loadedDataDictionary = workbook;
                    dataDictionaryStatus.textContent = `Dictionary "${result.filename}" loaded successfully!`;
                    dataDictionaryStatus.classList.remove('text-red-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-green-600');
                } else {
                    dataDictionaryStatus.textContent = `Error loading dictionary: ${result.message || 'Unknown error'}`;
                    dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-red-600');
                    loadedDataDictionary = null;
                    console.error('Error fetching data dictionary:', result.error || result.message);
                }
            } catch (error) {
                dataDictionaryStatus.textContent = `Network error loading dictionary: ${error.message}`;
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                dataDictionaryStatus.classList.add('text-red-600');
                loadedDataDictionary = null;
                console.error('Network error loading data dictionary:', error);
            } finally {
                loadDataDictionaryBtn.disabled = false; // Re-enable button
            }
        });

        /**
         * Updates the display element with the current date, used for future date flagging info.
         */
        function updateDynamicDateDisplay() {
            const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
            const dateElement = document.getElementById('dynamicTodayDate');
            if (dateElement) {
                dateElement.textContent = TODAY.toLocaleDateString('en-US', options);
            }
        }

        /**
         * Shows the loading spinner and hides results sections, resetting global state for a new analysis.
         */
        function showLoader() {
            document.getElementById('loader').style.display = 'block';
            document.getElementById('results').style.display = 'none';
            document.getElementById('summaryReportContainer').style.display = 'none';
            document.getElementById('generateSummaryBtn').style.display = 'none';
            document.getElementById('sheetResults').innerHTML = '';
            document.getElementById('fileName').textContent = '';
            
            // Reset all global data and stats for a fresh analysis
            workbookData = {};
            originalExcelWorkbook = null;
            overallStats = { blankCells: 0, nullValues: 0, futureDates: 0, duplicateRowCount: 0, totalProcessedDataCells: 0, totalRowsProcessedForDuplicates: 0 };
            hasDingedForHighPercentageCurrentFile = false;
            updateInitialOverallCountsDisplay(); // Clear display of previous overall counts
        }

        /**
         * Hides the loading spinner.
         */
        function hideLoader() {
            document.getElementById('loader').style.display = 'none';
        }
        
        /**
         * Updates the overall issue counts displayed prominently above the detailed sheet results.
         */
        function updateInitialOverallCountsDisplay() {
            document.getElementById('totalBlankCellsDisplay').textContent = `Overall Total Blank Cells (active): ${overallStats.blankCells}`;
            document.getElementById('totalNullCountDisplay').textContent = `Overall Total "NULL" Cells (active): ${overallStats.nullValues}`;
            document.getElementById('totalFutureDatesDisplay').textContent = `Overall Total Future Dates (active): ${overallStats.futureDates}`;
            document.getElementById('totalDuplicateRowsDisplay').textContent = `Overall Duplicate Rows Found: ${overallStats.duplicateRowCount}`;
        }
        
        /**
         * Renders the detailed analysis results for each worksheet and column into the UI.
         */
        function renderSheetResultsHTML() {
            const sheetResultsDiv = document.getElementById('sheetResults');
            sheetResultsDiv.innerHTML = ''; // Clear any previously rendered results
            
            Object.keys(workbookData).forEach(sheetName => {
                const sheetData = workbookData[sheetName];
                const sheetResultsContainer = document.createElement('div');
                sheetResultsContainer.classList.add('mb-8'); /* Add margin-bottom for spacing between sheets */
                sheetResultsContainer.innerHTML = `<h3 class="text-xl font-bold text-gray-800 mb-3">Sheet: ${sheetName}</h3>`; /* Styled heading */
                const columnsListUL = document.createElement('ul');
                columnsListUL.classList.add('space-y-4'); /* Add space between column list items */

                // Iterate through columns to render their specific issues and controls
                if (sheetData.columns && Object.keys(sheetData.columns).length > 0) {
                    Object.keys(sheetData.columns).forEach(columnName => {
                        const stats = sheetData.columns[columnName];
                        const listItem = document.createElement('li');
                        listItem.classList.add('p-3', 'bg-gray-50', 'rounded-lg', 'shadow-sm', 'border', 'border-gray-200'); /* Card-like style for each column */
                        
                        let issueDescriptions = [];
                        if (stats.blankCount > 0) issueDescriptions.push("blanks");
                        if (stats.nullStringCount > 0) issueDescriptions.push("NULLs");
                        if (stats.futureDateCount > 0) issueDescriptions.push("future dates");
                        
                        // Construct the descriptive text for column issues
                        let issueTextHTML = issueDescriptions.length > 0 ?
                            `<span class="text-red-600 font-semibold">Column "<strong>${columnName}</strong>" contains: ${issueDescriptions.join(', ')}.</span>` :
                            `<span class="text-green-600 font-semibold">Column "<strong>${columnName}</strong>" is clean.</span>`;
                        
                        // Sanitize column name for use in HTML IDs and data attributes (important for valid HTML)
                        const safeColumnName = columnName.replace(/[^a-zA-Z0-9]/g, "_");
                        const overrideCheckboxId = `override-${sheetName.replace(/[^a-zA-Z0-9]/g, "_")}-${safeColumnName}`;
                        
                        // Display individual issue counts (e.g., Blank=5 | NULL=2)
                        let countsDisplayParts = [];
                        if (stats.blankCount > 0) countsDisplayParts.push(`Blank=${stats.blankCount}`);
                        if (stats.nullStringCount > 0) countsDisplayParts.push(`NULL=${stats.nullStringCount}`);
                        if (stats.futureDateCount > 0) countsDisplayParts.push(`FutureDates=${stats.futureDateCount}`);
                        const countsDisplayHTML = countsDisplayParts.join(' | ');

                        // Build the HTML for each column's summary, including override checkbox and show/hide values button
                        listItem.innerHTML = `
                            <div class="flex flex-col md:flex-row md:items-center justify-between column-summary ${stats.isOverridden ? 'opacity-50 line-through' : ''}">
                                <div class="flex items-center mb-2 md:mb-0">
                                    <input type="checkbox" id="${overrideCheckboxId}" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 mr-2 override-checkbox" data-sheet="${sheetName}" data-column="${safeColumnName}" ${stats.isOverridden ? 'checked' : ''}>
                                    <label for="${overrideCheckboxId}" class="text-sm text-gray-700 mr-4">Override Issues</label>
                                    <span class="text-gray-900 text-base font-medium">${issueTextHTML}</span>
                                </div>
                                <div class="text-sm text-gray-600 italic">${countsDisplayHTML}</div>
                                <button class="ml-auto px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-md text-sm font-medium toggle-values-btn" data-sheet="${sheetName}" data-column="${safeColumnName}">Show Values</button>
                            </div>
                            <div class="column-values-container p-3 mt-3 bg-white border border-gray-300 rounded-lg shadow-inner" style="display:none; max-height: 250px; overflow-y: auto;"></div>
                        `;
                        columnsListUL.appendChild(listItem);
                    });
                } else {
                    const emptyColMsg = document.createElement('li');
                    emptyColMsg.textContent = "No columns found or processed for this sheet.";
                    emptyColMsg.classList.add('p-3', 'bg-gray-50', 'rounded-lg', 'text-gray-600');
                    columnsListUL.appendChild(emptyColMsg);
                }
                sheetResultsContainer.appendChild(columnsListUL);

                if (sheetData.duplicateInfo && sheetData.duplicateInfo.count > 0) {
                    const dupeInfoP = document.createElement('p');
                    dupeInfoP.classList.add('mt-4', 'text-gray-700', 'font-medium', 'text-center');
                    dupeInfoP.innerHTML = `<strong>Duplicate Rows Found in this sheet: ${sheetData.duplicateInfo.count}</strong> (see summary report for details)`;
                    sheetResultsContainer.appendChild(dupeInfoP);
                }
                sheetResultsDiv.appendChild(sheetResultsContainer);
            });
        }

        /**
         * Main function to analyze the uploaded Excel/CSV file.
         * It reads the file, parses it using XLSX.js, and detects various data quality issues.
         */
        function analyzeFile() {
            const fileInput = document.getElementById('excelFile');
            if (fileInput.files.length === 0) {
                alert("Please select a file to validate first.");
                return;
            }
            showLoader(); // Show loader and reset UI before processing
            const file = fileInput.files[0];
            currentFileName = file.name.replace(/\.(xlsx|xls|csv)$/i, '') + "_Reviewed.xlsx"; // Generate a name for the exported file
            document.getElementById('fileName').textContent = `File: ${file.name}`; // Display uploaded file name

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = new Uint8Array(event.target.result);
                    // Read Excel workbook using XLSX.js from ArrayBuffer
                    originalExcelWorkbook = XLSX.read(data, { type: 'array', cellNF: true, cellDates: false });
                    
                    document.getElementById('results').style.display = 'block'; // Show analysis results section
                    
                    overallStats.totalProcessedDataCells = 0; // Reset overall stats
                    overallStats.totalRowsProcessedForDuplicates = 0;

                    // Iterate through each sheet in the workbook
                    originalExcelWorkbook.SheetNames.forEach(sheetName => {
                        const worksheet = originalExcelWorkbook.Sheets[sheetName];
                        // Initialize data structure for the current sheet
                        workbookData[sheetName] = { columns: {}, duplicateInfo: { count: 0, rows: [] } };
                        
                        // Convert sheet to JSON array of arrays for easier processing, especially for duplicates
                        const jsonDataForDuplicates = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                        
                        // --- Duplicate Row Detection Logic ---
                        if (jsonDataForDuplicates.length > 0 || worksheet['!ref']) { // Check if sheet has data or is referenced
                            const seenRowStrings = new Map(); // To track seen row content
                            if (jsonDataForDuplicates.length > 1) { // Ensure there are data rows beyond header
                                overallStats.totalRowsProcessedForDuplicates += (jsonDataForDuplicates.length - 1); // Count data rows
                                for (let i = 1; i < jsonDataForDuplicates.length; i++) { // Iterate from the second row (assuming first is header)
                                    const currentRowData = jsonDataForDuplicates[i];
                                    // Create a consistent string representation of the row for uniqueness check (trim spaces, handle nulls)
                                    const rowString = currentRowData ? currentRowData.map(cell => cell === null || cell === undefined ? "" : String(cell).trim()).join('~!~') : null;
                                    
                                    if (rowString !== null) { // Only process if row has content
                                        if (seenRowStrings.has(rowString)) { // If this row content has been seen before
                                            const firstSeenJsonIndex = seenRowStrings.get(rowString);
                                            // Check if this exact duplicate instance is already recorded
                                            const alreadyRecorded = workbookData[sheetName].duplicateInfo.rows.some(r => r.originalRowIndex === (i + 1) && !r.isFirstOccurrence);
                                            
                                            if (!alreadyRecorded) {
                                                workbookData[sheetName].duplicateInfo.count++; // Increment sheet-specific duplicate count
                                                overallStats.duplicateRowCount++; // Increment global duplicate count
                                                workbookData[sheetName].duplicateInfo.rows.push({
                                                    originalRowIndex: i + 1, // Store Excel row number (1-indexed)
                                                    isFirstOccurrence: false,
                                                    duplicateOf: firstSeenJsonIndex + 1, // Row number of its first occurrence
                                                    data: currentRowData // Store raw row data for sample display in report
                                                });
                                                // Also ensure the *first* occurrence of this duplicate set is recorded
                                                if (!workbookData[sheetName].duplicateInfo.rows.find(r => r.originalRowIndex === (firstSeenJsonIndex + 1))) {
                                                    workbookData[sheetName].duplicateInfo.rows.push({
                                                        originalRowIndex: firstSeenJsonIndex + 1,
                                                        isFirstOccurrence: true,
                                                        duplicateOf: null,
                                                        data: jsonDataForDuplicates[firstSeenJsonIndex]
                                                    });
                                                }
                                            }
                                        } else {
                                            seenRowStrings.set(rowString, i); // Record index of first occurrence
                                        }
                                    }
                                }
                            }
                        }

                        // --- Column-level Issue Detection (Blanks, "NULL" strings, Future Dates) ---
                        const headers = jsonDataForDuplicates[0] || []; // Get headers (first row data)
                        const sheetColumnStats = {};
                        const range = XLSX.utils.decode_range(worksheet['!ref'] || "A1:A1"); // Get actual used range of sheet (e.g., A1:C5)
                        // Determine the maximum number of columns to iterate through based on headers or actual range
                        const maxCols = (headers.length > 0) ? headers.length : (range.e.c + 1);

                        // Initialize stats for each detected column
                        for (let C = 0; C < maxCols; C++) {
                            const columnName = (headers[C] !== null && headers[C] !== undefined) ? String(headers[C]) : `Column ${XLSX.utils.encode_col(C)}`; // Default to "Column A", "Column B" etc.
                            sheetColumnStats[columnName] = { blankCount: 0, nullStringCount: 0, futureDateCount: 0, hasIssue: false, values: [], isOverridden: false };
                        }
                        
                        const actualHeaderKeys = Object.keys(sheetColumnStats); // Get actual column names for iteration

                        // Calculate total processed cells for overall clean rate (excluding header row)
                        if (range.e.r >= range.s.r + 1 && actualHeaderKeys.length > 0) {
                            overallStats.totalProcessedDataCells += (range.e.r - range.s.r) * actualHeaderKeys.length;
                        }

                        // Iterate through cells of the current sheet and collect stats
                        for (let R = range.s.r + 1; R <= range.e.r; ++R) { // Start from the second row (data rows)
                            for (let C = range.s.c; C <= Math.min(range.e.c, maxCols - 1); ++C) { // Iterate up to the determined maxCols
                                const cellAddress = XLSX.utils.encode_cell({ r: R, c: C }); // Get Excel cell address (e.g., A2, B5)
                                const cell = worksheet[cellAddress]; // Get cell object from worksheet
                                let cellValueToStore = cell ? cell.v : null; // Raw value from XLSX.js cell object
                                let processedCellValue = cellValueToStore; // Value potentially processed for type (e.g., Date object)
                                const columnName = actualHeaderKeys[C]; // Get the column's header name

                                if (!columnName) continue;

                                // Special handling for dates to convert Excel's numeric date to JavaScript Date object
                                if (cell && cell.t === 'n' && cell.z && XLSX.SSF.is_date(cell.z)) {
                                    const dateInfo = XLSX.SSF.parse_date_code(cell.v);
                                    if (dateInfo) {
                                        // Create UTC Date object to avoid timezone issues during comparison
                                        processedCellValue = new Date(Date.UTC(dateInfo.y, dateInfo.m - 1, dateInfo.d, dateInfo.H || 0, dateInfo.M || 0, dateInfo.S || 0));
                                        cellValueToStore = processedCellValue;
                                    } else {
                                        processedCellValue = cell.v;
                                    }
                                }

                                // Store the value along with its original row number for display
                                sheetColumnStats[columnName].values.push({ value: cellValueToStore, originalDataRow: R });

                                // Perform issue checks
                                if (processedCellValue instanceof Date && !isNaN(processedCellValue.getTime())) {
                                    // Normalize cell date to UTC midnight for comparison with TODAY
                                    const cellDateOnly = new Date(Date.UTC(processedCellValue.getUTCFullYear(), processedCellValue.getUTCMonth(), processedCellValue.getUTCDate()));
                                    if (cellDateOnly > TODAY) { // Check if date is in the future
                                        sheetColumnStats[columnName].futureDateCount++;
                                        sheetColumnStats[columnName].hasIssue = true;
                                    }
                                } else if (processedCellValue !== null && processedCellValue !== undefined && String(processedCellValue).trim().toUpperCase() === "NULL") {
                                    // Check for the string "NULL" (case-insensitive, trimmed)
                                    sheetColumnStats[columnName].nullStringCount++;
                                    sheetColumnStats[columnName].hasIssue = true;
                                } else if (processedCellValue === null || String(processedCellValue).trim() === "") {
                                    // Check for truly blank cells (null or empty string after trimming)
                                    sheetColumnStats[columnName].blankCount++;
                                    sheetColumnStats[columnName].hasIssue = true;
                                }
                            }
                        }
                        workbookData[sheetName].columns = sheetColumnStats; // Store collected column stats
                    });
                    
                    recalculateGlobalOverallStatsFromWorkbookData(); // Update global stats based on all sheets
                    renderSheetResultsHTML(); // Render the initial analysis results in the UI
                    updateInitialOverallCountsDisplay(); // Update the prominent overall counts
                    document.getElementById('generateSummaryBtn').style.display = 'inline-block'; // Show the "View Summary Report" button
                } catch (error) {
                    console.error("Error processing file:", error);
                    document.getElementById('sheetResults').innerHTML = `<p class="text-red-600">Error processing file: ${error.message}. Make sure it's a valid Excel/CSV file.</p>`;
                    updateInitialOverallCountsDisplay();
                } finally {
                    hideLoader();
                }
            };
            reader.readAsArrayBuffer(file); // Start reading the file as an ArrayBuffer
        }
        
        /**
         * Generates and displays the comprehensive summary report in a separate section.
         * This report is also the basis for the Excel export.
         * @param {boolean} shouldScrollToReport - If true, the page will scroll to the report section.
         */
        function generateSummaryReport(shouldScrollToReport = true) {
            const summaryContainer = document.getElementById('summaryReportContainer');
            summaryContainer.innerHTML = ''; // Clear previous report content
            recalculateGlobalOverallStatsFromWorkbookData(); // Ensure global stats are up-to-date with overrides

            // Calculate overall data quality metrics
            const totalCellLevelIssues = overallStats.blankCells + overallStats.nullValues + overallStats.futureDates;
            const totalEffectiveIssues = totalCellLevelIssues + overallStats.duplicateRowCount;
            // Denominator for issue rate, ensuring no division by zero
            const issueRateDenominator = (overallStats.totalProcessedDataCells + overallStats.totalRowsProcessedForDuplicates) || 1;
            const issueRate = (totalEffectiveIssues / issueRateDenominator) * 100;
            const cleanRate = Math.max(0, 100 - issueRate); // Clean rate cannot be negative
            const passFailStatus = cleanRate >= CLEAN_RATE_PASS_THRESHOLD ? "Pass" : "Fail";
            const passFailClass = passFailStatus === "Pass" ? "text-green-600" : "text-red-600";

            // Play a success sound if clean rate meets threshold and hasn't played for this file yet
            if (passFailStatus === "Pass" && !hasDingedForHighPercentageCurrentFile) {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.speak(new SpeechSynthesisUtterance("Validation passed"));
                }
                hasDingedForHighPercentageCurrentFile = true;
            } else if (passFailStatus === "Fail") {
                hasDingedForHighPercentageCurrentFile = false; // Reset flag if validation fails
            }

            // Build the HTML for the overall statistics summary section
            let reportHTML = `<h1 class="text-2xl font-bold text-blue-700 mb-4 text-center">Data Quality Summary Report</h1><div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h2>Overall Statistics (Column Issue Overrides Applied)</h2>`;
            reportHTML += `<p class="text-gray-700"><strong>File:</strong> ${document.getElementById('fileName').textContent.replace('File: ', '')}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Processed Data Cells:</strong> ${overallStats.totalProcessedDataCells}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Rows Processed (for duplicates):</strong> ${overallStats.totalRowsProcessedForDuplicates}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Blank Cells (effective):</strong> ${overallStats.blankCells}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total "NULL" Cells (effective):</strong> ${overallStats.nullValues}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Future Dates (effective):</strong> ${overallStats.futureDates}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Duplicate Rows Found:</strong> ${overallStats.duplicateRowCount}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Cell-Level Issues (effective):</strong> ${totalCellLevelIssues}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Effective Issues (Cells + Duplicates):</strong> ${totalEffectiveIssues}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Issue Rate (approximate):</strong> ${issueRate.toFixed(2)}%</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Clean Rate (approximate):</strong> ${cleanRate.toFixed(2)}%</p>`;
            reportHTML += `<p class="text-lg font-semibold mt-4"><strong>Status: <span class="${passFailClass}">${passFailStatus}</span></strong> (Threshold: ${CLEAN_RATE_PASS_THRESHOLD}% clean)</p></div>`;
            
            reportHTML += `<div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h2>Detailed Issues by Column (Raw Counts)</h2><table class="w-full text-left table-auto border-collapse"><thead><tr class="bg-gray-200"><th>Sheet</th><th>Column</th><th>Blanks</th><th>NULLs</th><th>Future Dates</th><th>Overridden</th></tr></thead><tbody>`;
            
            let issuesFoundDetails = false;
            Object.keys(workbookData).forEach(sheetName => {
                const sheetColData = workbookData[sheetName].columns;
                if (sheetColData) {
                    Object.keys(sheetColData).forEach(columnName => {
                        const stats = sheetColData[columnName];
                        if (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0 || stats.isOverridden) {
                            issuesFoundDetails = true;
                            const safeColName = columnName.replace(/[^a-zA-Z0-9]/g, "_");
                            const overriddenMarker = stats.isOverridden ? ' <span class="text-gray-500 text-xs italic">(Overridden)</span>' : '';
                            const overriddenClass = stats.isOverridden ? 'opacity-50 line-through' : '';
                            reportHTML += `<tr class="border-b border-gray-200"><td>${sheetName}</td><td>${columnName}${overriddenMarker}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="blankCount">${stats.blankCount}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="nullStringCount">${stats.nullStringCount}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="futureDateCount">${stats.futureDateCount}</td><td>${stats.isOverridden ? "Yes" : "No"}</td></tr>`;
                        }
                    });
                }
            });
            if (!issuesFoundDetails) reportHTML += `<tr><td colspan="6" class="text-center text-gray-500 py-4">No specific column issues found or overridden.</td></tr>`;
            reportHTML += `</tbody></table></div>`;

            reportHTML += `<div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h3>Duplicate Row Details</h3><table class="w-full text-left table-auto border-collapse"><thead><tr class="bg-gray-200"><th>Sheet</th><th>Duplicate Row #</th><th>First Seen At Row #</th><th>Sample Data (First 3 Cells)</th></tr></thead><tbody>`;
            
            let duplicatesListed = false;
            Object.keys(workbookData).forEach(sheetName => {
                const { duplicateInfo } = workbookData[sheetName];
                if (duplicateInfo && duplicateInfo.rows) {
                    const sortedDuplicates = [...duplicateInfo.rows].sort((a, b) => {
                        if (a.originalRowIndex !== b.originalRowIndex) {
                            return a.originalRowIndex - b.originalRowIndex;
                        }
                        return a.isFirstOccurrence ? -1 : 1;
                    });

                    sortedDuplicates.forEach(dupeRow => {
                        if (!dupeRow.isFirstOccurrence) {
                            duplicatesListed = true;
                            const sample = dupeRow.data.slice(0, 3).map(d => {
                                if (d === null || d === undefined) return "";
                                if (d instanceof Date) return d.toLocaleDateString('en-US', {timeZone: 'UTC'});
                                return String(d);
                            }).join(', ');
                            reportHTML += `<tr class="border-b border-gray-200"><td>${sheetName}</td><td>${dupeRow.originalRowIndex}</td><td>${dupeRow.duplicateOf}</td><td>${sample}...</td></tr>`;
                        }
                    });
                }
            });
            if (!duplicatesListed) reportHTML += `<tr><td colspan="4" class="text-center text-gray-500 py-4">No duplicate rows found.</td></tr>`;
            reportHTML += `</tbody></table></div>`;

            reportHTML += `<div class="flex justify-center space-x-4 print-hidden">`;
            reportHTML += `<button id="printSummaryBtn" onclick="window.print()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-300">Print Report</button>`;
            reportHTML += `<button id="exportExcelBtn" onclick="exportExcelWithSummary()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-300">Export Excel w/ Summary</button>`;
            reportHTML += `</div>`;
            
            summaryContainer.innerHTML = reportHTML;
            summaryContainer.style.display = 'block';
            if (shouldScrollToReport) summaryContainer.scrollIntoView({ behavior: 'smooth' });
        }

        document.getElementById('sheetResults').addEventListener('click', function(event) {
            const target = event.target;
            if (target.classList.contains('override-checkbox')) {
                const { sheet, column } = target.dataset;
                const originalColName = findOriginalColumnName(sheet, column);
                if (workbookData[sheet]?.columns?.[originalColName]) {
                    workbookData[sheet].columns[originalColName].isOverridden = target.checked;
                    target.closest('.column-summary').classList.toggle('opacity-50', target.checked);
                    target.closest('.column-summary').classList.toggle('line-through', target.checked);
                    recalculateGlobalOverallStatsFromWorkbookData();
                    updateInitialOverallCountsDisplay();
                    if (document.getElementById('summaryReportContainer').style.display !== 'none') {
                        generateSummaryReport(false);
                    }
                }
            } else if (target.classList.contains('toggle-values-btn')) {
                const { sheet, column } = target.dataset;
                const originalColName = findOriginalColumnName(sheet, column);
                const valuesContainer = target.closest('li').querySelector('.column-values-container');
                if (!workbookData[sheet]?.columns?.[originalColName]) {
                    console.error("Data not found for:", sheet, originalColName);
                    return;
                }
                if (valuesContainer.style.display === 'none') {
                    valuesContainer.innerHTML = '';
                    const stats = workbookData[sheet].columns[originalColName];
                    const sortableValues = stats.values.map(item => {
                        const val = item.value;
                        const stringValue = (val === null || val === undefined) ? "" : String(val).trim();
                        const isFuture = (val instanceof Date && !isNaN(val.getTime()) && new Date(Date.UTC(val.getUTCFullYear(), val.getUTCMonth(), val.getUTCDate())) > TODAY);
                        const isBlank = (val === null || stringValue === "");
                        const isNullString = (val !== null && val !== undefined && stringValue.toUpperCase() === "NULL");
                        const isInvalidDate = (val instanceof Date && isNaN(val.getTime()));
                        const hasAnyIssue = isFuture || isBlank || isNullString || isInvalidDate;
                        return { ...item, value: val, isFuture, isBlank, isNullString, isInvalidDate, hasAnyIssue };
                    });
                    sortableValues.sort((a, b) => (a.hasAnyIssue === b.hasAnyIssue) ? a.originalDataRow - b.originalDataRow : a.hasAnyIssue ? -1 : 1);

                    if (sortableValues.length > 0) {
                        const ul = document.createElement('ul');
                        ul.classList.add('space-y-1');
                        sortableValues.forEach(item => {
                            const { value, originalDataRow } = item;
                            const li = document.createElement('li');
                            let displayValue;
                            let valueClass = '';

                            if (item.isFuture) { valueClass = 'text-red-500 font-bold'; displayValue = `Row ${originalDataRow + 1}: Future Date - ${value.toLocaleDateString('en-US', {timeZone: 'UTC'})}`; }
                            else if (item.isBlank) { valueClass = 'text-orange-500 italic'; displayValue = `Row ${originalDataRow + 1}: Blank Cell (${value === null ? 'null' : 'empty string'})`; }
                            else if (item.isNullString) { valueClass = 'text-red-500 italic'; displayValue = `Row ${originalDataRow + 1}: NULL String Issue - "${value}"`; }
                            else if (item.isInvalidDate) { valueClass = 'text-red-500 italic'; displayValue = `Row ${originalDataRow + 1}: Invalid Date Object - "${String(value)}"`; }
                            else if (value instanceof Date) { valueClass = 'text-blue-600'; displayValue = `Row ${originalDataRow + 1}: ${value.toLocaleDateString('en-US', {timeZone: 'UTC'})}`; }
                            else if (typeof value === 'object' && value !== null) { try { displayValue = `Row ${originalDataRow + 1}: Value: ${JSON.stringify(value)}`; } catch (e) { displayValue = `Row ${originalDataRow + 1}: Value: [Object]`; } }
                            else { displayValue = `Row ${originalDataRow + 1}: Value: ${value}`; }

                            li.textContent = displayValue;
                            if (valueClass) li.classList.add(valueClass);
                            else if(item.hasAnyIssue) li.classList.add('text-orange-600', 'font-bold');
                            ul.appendChild(li);
                        });
                        valuesContainer.appendChild(ul);
                    } else {
                        valuesContainer.innerHTML = '<p class="text-gray-500 italic">This column has no data rows.</p>';
                    }
                    valuesContainer.style.display = 'block';
                    target.textContent = 'Hide Values';
                } else {
                    valuesContainer.style.display = 'none';
                    valuesContainer.innerHTML = '';
                    target.textContent = 'Show Values';
                }
            }
        });

        function findOriginalColumnName(sheet, colFromDataset) {
            const cols = workbookData[sheet]?.columns;
            if (!cols) return colFromDataset;
            if (cols[colFromDataset]) return colFromDataset;
            return Object.keys(cols).find(k => k.replace(/[^a-zA-Z0-9]/g, "_") === colFromDataset) || colFromDataset;
        }

        function recalculateGlobalOverallStatsFromWorkbookData() {
            let newBlank = 0, newNull = 0, newFuture = 0;
            Object.values(workbookData).forEach(({ columns }) => {
                if(columns) Object.values(columns).forEach(stats => {
                    if (!stats.isOverridden) {
                        newBlank += parseInt(stats.blankCount, 10) || 0;
                        newNull += parseInt(stats.nullStringCount, 10) || 0;
                        newFuture += parseInt(stats.futureDateCount, 10) || 0;
                    }
                });
            });
            overallStats.blankCells = newBlank;
            overallStats.nullValues = newNull;
            overallStats.futureDates = newFuture;
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('summaryReportContainer')?.addEventListener('blur', function(event) {
                if (event.target.classList.contains('editable-stat')) {
                    const td = event.target;
                    const { sheet, column, type } = td.dataset;
                    const originalColName = findOriginalColumnName(sheet, column);
                    const newValue = parseInt(td.textContent.trim(), 10);

                    if (workbookData[sheet]?.columns?.[originalColName]) {
                        const stats = workbookData[sheet].columns[originalColName];
                        if (isNaN(newValue) || newValue < 0 || td.textContent.trim() === "") {
                            alert("Please enter a valid non-negative number.");
                            td.textContent = stats[type];
                            return;
                        }
                        stats[type] = newValue;
                        stats.hasIssue = (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0); 
                        recalculateGlobalOverallStatsFromWorkbookData();
                        if (document.getElementById('summaryReportContainer').style.display !== 'none') {
                            generateSummaryReport(false);
                        } else {
                            updateInitialOverallCountsDisplay();
                        }
                    } else {
                        console.error("Editable cell event: Could not find column data for update:", sheet, originalColName);
                    }
                }
            }, true);
        });

        function exportExcelWithSummary() {
            if (!originalExcelWorkbook) {
                alert("Please analyze a file first to generate data for export.");
                return;
            }
            recalculateGlobalOverallStatsFromWorkbookData();

            const wb = XLSX.utils.book_new();

            originalExcelWorkbook.SheetNames.forEach(sheetName => {
                const sheetData = XLSX.utils.sheet_to_json(originalExcelWorkbook.Sheets[sheetName], {header:1, defval:null});
                XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(sheetData), sheetName);
            });

            const summaryAoA = [];
            const { blankCells, nullValues, futureDates, duplicateRowCount, totalProcessedDataCells, totalRowsProcessedForDuplicates } = overallStats;
            const totalCellIssues = blankCells + nullValues + futureDates;
            const totalEffectiveIssues = totalCellIssues + duplicateRowCount;
            const denominator = (totalProcessedDataCells + totalRowsProcessedForDuplicates) || 1;
            const issueRate = (totalEffectiveIssues / denominator) * 100;
            const cleanRate = Math.max(0, 100 - issueRate);
            const status = cleanRate >= CLEAN_RATE_PASS_THRESHOLD ? "Pass" : "Fail";

            summaryAoA.push(["Data Quality Summary Report"]);
            summaryAoA.push([]);
            summaryAoA.push(["Overall Statistics"]);
            summaryAoA.push(["File:", document.getElementById('fileName').textContent.replace('File: ', '')]);
            summaryAoA.push(["Total Processed Data Cells:", totalProcessedDataCells]);
            summaryAoA.push(["Total Rows Processed (for duplicates):", totalRowsProcessedForDuplicates]);
            summaryAoA.push(["Total Blank Cells (effective):", blankCells]);
            summaryAoA.push(["Total \"NULL\" Cells (effective):", nullValues]);
            summaryAoA.push(["Total Future Dates (effective):", futureDates]);
            summaryAoA.push(["Total Duplicate Rows Found:", duplicateRowCount]);
            summaryAoA.push(["Total Cell-Level Issues (effective):", totalCellIssues]);
            summaryAoA.push(["Total Effective Issues (Cells + Duplicates):", totalEffectiveIssues]);
            summaryAoA.push(["Issue Rate (approximate):", `${issueRate.toFixed(2)}%`]);
            summaryAoA.push(["Clean Rate (approximate):", `${cleanRate.toFixed(2)}%`]);
            summaryAoA.push(["Status:", `${status} (Threshold: ${CLEAN_RATE_PASS_THRESHOLD}% clean)`]);
            summaryAoA.push([]);

            summaryAoA.push(["Detailed Issues by Column (Raw Counts)"]);
            summaryAoA.push(["Sheet", "Column", "Blanks", "NULLs", "Future Dates", "Overridden"]);
            
            let detailsAdded = false;
            Object.entries(workbookData).forEach(([sheetName, { columns }]) => {
                if (columns) {
                    Object.entries(columns).forEach(([columnName, stats]) => {
                        if (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0 || stats.isOverridden) {
                            detailsAdded = true;
                            summaryAoA.push([sheetName, columnName, stats.blankCount, stats.nullStringCount, stats.futureDateCount, stats.isOverridden ? "Yes" : "No"]);
                        }
                    });
                }
            });
            if (!detailsAdded) summaryAoA.push(["No columns with issues or overrides to report."]);
            summaryAoA.push([]);

            summaryAoA.push(["Duplicate Row Details"]);
            summaryAoA.push(["Sheet", "Duplicate Row #", "First Seen At Row #", "Sample Data (First 3 Cells)"]);
            
            let duplicatesExported = false;
            Object.entries(workbookData).forEach(([sheetName, { duplicateInfo }]) => {
                if (duplicateInfo && duplicateInfo.rows) {
                    const duplicatesToExport = duplicateInfo.rows.filter(dupe => !dupe.isFirstOccurrence).sort((a, b) => a.originalRowIndex - b.originalRowIndex);

                    duplicatesToExport.forEach(dupe => {
                        duplicatesExported = true;
                        const sample = dupe.data.slice(0, 3).map(d => {
                            if (d === null || d === undefined) return "";
                            if (d instanceof Date) return d.toLocaleDateString('en-US', {timeZone: 'UTC'});
                            return String(d);
                        }).join(', ');
                        summaryAoA.push([sheetName, dupe.originalRowIndex, dupe.duplicateOf, `${sample}...`]);
                    });
                }
            });
            if (!duplicatesExported) summaryAoA.push(["No duplicate rows found."]);

            const summaryWS = XLSX.utils.aoa_to_sheet(summaryAoA);
            XLSX.utils.book_append_sheet(wb, summaryWS, "Summary Report");

            XLSX.writeFile(wb, currentFileName);
        }
    </script>
</body>
</html>
```
I understand you're pointing to the `file-manager-frontend` Canvas and stating that you're leaving off at #3 (which in the previous conversation refers to integrating data dictionaries into the `validation-engine.html`).

You've provided the code for the `file-manager-frontend` Canvas. I have included the `selection-tag` in my response to accurately reflect your prompt.

Let's continue with the integration of data dictionaries into the `validation-engine.html` file, which is the next logical step based on your project goals.

### **Action Plan: Update `public/tools/validation-engine.html` to Select Data Dictionaries**

This step will add the UI elements and JavaScript logic to:
1.  Fetch *only* data dictionary files from your `/api/list-files` endpoint when the page loads.
2.  Populate a dropdown with these data dictionaries.
3.  Allow the user to select a data dictionary.
4.  When selected, download the chosen data dictionary file's content (via `/api/get-file`) and parse it using `xlsx.full.min.js`, storing its workbook data for later use in validation.

Here is the updated code for your `public/tools/validation-engine.html` file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Validate - MirraBuddy</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- XLSX library for client-side Excel file parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
        }
        /* Loader Animation - specific CSS needed for animation */
        .loader {
            border: 6px solid #e9ecef;
            border-top: 6px solid #2D62B3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            display: none; /* Hidden by default */
            margin: 25px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Specific print styles to hide UI elements */
        @media print {
            body { background-color: #fff; }
            body * { visibility: hidden; }
            #summaryReportContainer, #summaryReportContainer * { visibility: visible; }
            #summaryReportContainer { position: absolute; left: 0; top: 0; width: 100%; border: none !important; box-shadow: none !important; margin:0 !important; padding:0 !important; border-radius: 0; }
            .print-hidden { display: none !important; } /* Class to hide elements specifically when printing */
            #summaryReportContainer h1, #summaryReportContainer h2, #summaryReportContainer h3, #summaryReportContainer h4 { color: black !important; border: none !important; }
            #summaryReportContainer table, #summaryReportContainer th, #summaryReportContainer td { border: 1px solid #666 !important; }
            #summaryReportContainer th { background-color: #eee !important; }
            a { text-decoration: none; color: black !important; }
            .pass-status { color: #006400 !important; }
            .fail-status { color: #8B0000 !important; }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen text-gray-800">
    <!-- Header Section: Consistent navigation across the app -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 p-4 shadow-lg print-hidden">
        <div class="container mx-auto flex flex-col sm:flex-row items-center justify-between">
            <h1 class="text-white text-3xl font-bold mb-2 sm:mb-0">Excel Validate</h1>
            <nav>
                <ul class="flex space-x-4">
                    <li><a href="/dashboard.html" class="text-white hover:text-blue-200 transition duration-300">Dashboard</a></li>
                    <li><a href="/tools.html" class="text-white hover:text-blue-200 transition duration-300">Tools List</a></li>
                    <li><a href="/tools/data-cleaner.html" class="text-white hover:text-blue-200 transition duration-300">Data Cleaner</a></li>
                    <li><a href="/tools/validation-engine.html" class="text-white hover:text-blue-200 transition duration-300 active">Excel Validate</a></li>
                    <li><a href="#" id="profileLink" class="text-white hover:text-blue-200 transition duration-300">Profile</a></li>
                    <li><a href="#" id="logoutBtn" class="text-white hover:text-blue-200 transition duration-300 cursor-pointer">Logout</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content Section: Central area for the tool's functionality -->
    <main class="flex-grow container mx-auto p-4 sm:p-6 lg:p-8">
        <section class="bg-white p-6 sm:p-8 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl sm:text-3xl font-semibold text-center text-blue-700 mb-4">
                Validate Your Excel Data Against Custom Rules
            </h2>
            <p class="text-lg text-gray-700 text-center mb-6">
                Ensure the integrity and accuracy of your spreadsheets by setting up and running powerful validation rules.
            </p>
            <div class="max-w-xl mx-auto text-gray-600 text-base mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
                <p class="font-semibold text-gray-800 mb-2">About This Tool:</p>
                <p>The **Validation Engine** helps you define and enforce data quality standards for your Excel files. It performs a comprehensive analysis of your data to identify common issues such as blank cells, "NULL" string entries, and dates that fall in the future. Additionally, it identifies duplicate rows within your sheets, ensuring data uniqueness. You can selectively ignore ("override") specific column issues from the overall Pass/Fail calculation in the summary report. This tool is ideal for pre-processing data for analysis, reporting, or database imports, ensuring your datasets are clean and reliable.</p>
                <ul class="list-disc list-inside mt-3 ml-5">
                    <li>**Blank Cells:** Detects and counts empty cells.</li>
                    <li>**"NULL" Strings:** Flags cells containing the literal string "NULL" (case-insensitive).</li>
                    <li>**Future Dates:** Identifies dates that are set after today's date.</li>
                    <li>**Duplicate Rows:** Pinpoints entire rows that are identical, indicating redundant entries.</li>
                    <li>**Override Issues:** Allows you to exclude specific column issues from the final data quality score if they are intentional.</li>
                </ul>
                <p class="mt-3">Upload your file, review the real-time analysis results, override irrelevant issues, and generate a detailed summary report. You can then print the report or export it along with your original data to a new Excel file.</p>
            </div>

            <div class="max-w-xl mx-auto bg-green-50 p-6 rounded-lg shadow-md border border-green-200">
                <h3 class="text-xl font-bold text-green-600 mb-4">Upload File & Analyze</h3>
                <form id="analyzeForm" class="space-y-4">
                    <div>
                        <label for="excelFile" class="block text-sm font-medium text-gray-700">Select Excel or CSV File to Validate</label>
                        <input type="file" id="excelFile" accept=".xlsx, .xls, .csv" required
                               class="mt-1 block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-white focus:outline-none focus:border-green-500">
                    </div>

                    {/* NEW: Data Dictionary Selection */}
                    <div class="border-t border-gray-200 pt-4">
                        <h4 class="text-lg font-bold text-gray-700 mb-2">Optional: Select a Data Dictionary</h4>
                        <p class="text-sm text-gray-600 mb-3">Choose an uploaded data dictionary to use its rules for validation.</p>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <select id="dataDictionarySelect" class="flex-grow p-2 border border-gray-300 rounded-lg bg-white focus:ring-blue-500 focus:border-blue-500">
                                <option value="">-- No Data Dictionary Selected --</option>
                                {/* Options will be loaded here by JavaScript */}
                            </select>
                            <button type="button" id="loadDataDictionaryBtn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm transition duration-300">Load Dictionary</button>
                        </div>
                        <div id="dataDictionaryStatus" class="mt-2 text-sm text-gray-600 hidden"></div>
                    </div>
                    {/* End NEW: Data Dictionary Selection */}

                    <button type="button" id="analyzeFileBtn" onclick="analyzeFile()"
                            class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-lg text-lg font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-300 ease-in-out transform hover:-translate-y-0.5">
                        Analyze File
                    </button>
                </form>

                <div class="loader" id="loader"></div>

                <div id="results" class="mt-8 hidden">
                    <h2 class="text-xl font-bold text-gray-800 mb-4">Analysis Results</h2>
                    <p id="fileName" class="text-gray-700 font-medium mb-4"></p>
                    <div id="overallCounts" class="bg-gray-100 p-4 rounded-lg shadow-inner mb-6">
                        <p id="totalBlankCellsDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalNullCountDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalFutureDatesDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalDuplicateRowsDisplay" class="text-gray-800 text-base font-medium"></p>
                    </div>
                    <div id="sheetResults"></div>
                    <button id="generateSummaryBtn" onclick="generateSummaryReport()" class="mt-6 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition duration-300 hidden">View Summary Report</button>
                </div>
            </div>

            <div id="summaryReportContainer" class="content-box mt-8" style="display:none;">
            </div>
        </section>
    </main>

    <!-- Footer Section -->
    <footer class="bg-gray-800 text-white p-4 mt-8 print-hidden">
        <div class="container mx-auto text-center text-sm">
            &copy; 2025 Excel Buddy. All rights reserved.
        </div>
    </footer>

    <script>
        // --- Authentication Check and Logout Functionality (Adapted for consistency with existing project) ---
        document.addEventListener('DOMContentLoaded', async () => {
            const token = localStorage.getItem('jwtToken');
            if (!token) {
                window.location.href = '/'; // Redirects to index.html
                return;
            }
            try {
                const response = await fetch('/api/protected', {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) {
                    localStorage.removeItem('jwtToken');
                    window.location.href = '/';
                } else {
                    updateDynamicDateDisplay();
                    loadDataDictionaries(); // NEW: Call to load data dictionaries on successful auth
                }
            } catch (error) {
                console.error('Error verifying token on Validation Engine page:', error);
                localStorage.removeItem('jwtToken');
                window.location.href = '/';
            }
            // updateDynamicDateDisplay(); // Moved inside successful auth block
        });

        const logoutButton = document.getElementById('logoutBtn');
        if (logoutButton) {
            logoutButton.addEventListener('click', function() {
                localStorage.removeItem('jwtToken');
                window.location.href = '/';
            });
        }
        // --- End of Authentication consistency adaptation ---


        let workbookData = {}; // Stores all parsed data and analysis results
        let originalExcelWorkbook = null; // Stores the original XLSX.js workbook object
        let currentFileName = "ReviewedData.xlsx"; // Default filename for export
        // Overall statistics, dynamically updated based on user overrides
        let overallStats = { blankCells: 0, nullValues: 0, futureDates: 0, duplicateRowCount: 0, totalProcessedDataCells: 0, totalRowsProcessedForDuplicates: 0 };
        const TODAY = new Date();
        TODAY.setUTCHours(0, 0, 0, 0); // Normalize today's date to UTC midnight for consistent date comparisons
        const CLEAN_RATE_PASS_THRESHOLD = 95; // Threshold for "Pass" status in clean rate
        let hasDingedForHighPercentageCurrentFile = false; // Flag to prevent repeated speech notifications
        let loadedDataDictionary = null; // NEW: To store the content of the loaded data dictionary workbook

        // --- NEW DOM Elements for Data Dictionary Selection ---
        const dataDictionarySelect = document.getElementById('dataDictionarySelect');
        const loadDataDictionaryBtn = document.getElementById('loadDataDictionaryBtn');
        const dataDictionaryStatus = document.getElementById('dataDictionaryStatus');

        /**
         * Loads data dictionary files from the backend (File Manager's list-files endpoint)
         * and populates the dropdown. Filters for files marked as is_data_dictionary.
         */
        async function loadDataDictionaries() {
            dataDictionarySelect.innerHTML = '<option value="">-- Loading Dictionaries... --</option>'; // Initial loading state
            const token = localStorage.getItem('jwtToken');
            if (!token) {
                dataDictionarySelect.innerHTML = '<option value="">-- Login to Load Dictionaries --</option>';
                return;
            }

            try {
                // Fetch files from /api/list-files. We'll filter for data dictionaries on the frontend for now.
                // A future enhancement could be to add a query parameter to list-files.js
                const response = await fetch('/api/list-files', {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json();

                if (response.ok && result.files) {
                    // Filter files to only include those marked as data dictionaries
                    const dataDictionaries = result.files.filter(file => file.is_data_dictionary);

                    dataDictionarySelect.innerHTML = '<option value="">-- No Data Dictionary Selected --</option>'; // Reset dropdown
                    dataDictionaries.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file.id; // Use file ID as the option value
                        option.textContent = file.filename; // Display filename
                        dataDictionarySelect.appendChild(option);
                    });

                    if (dataDictionaries.length > 0) {
                        dataDictionaryStatus.textContent = `Loaded ${dataDictionaries.length} dictionaries.`;
                        dataDictionaryStatus.classList.remove('hidden', 'text-red-600');
                        dataDictionaryStatus.classList.add('text-green-600');
                    } else {
                        dataDictionaryStatus.textContent = `No data dictionaries uploaded for your company.`;
                        dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-red-600');
                        dataDictionaryStatus.classList.add('text-gray-600');
                    }
                } else {
                    dataDictionarySelect.innerHTML = '<option value="">-- Error Loading Dictionaries --</option>';
                    dataDictionaryStatus.textContent = `Error loading dictionaries: ${result.message || 'Unknown error'}`;
                    dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-red-600');
                    console.error('Error loading data dictionaries:', result.error || result.message);
                }
            } catch (error) {
                dataDictionarySelect.innerHTML = '<option value="">-- Network Error --</option>';
                dataDictionaryStatus.textContent = `Network error loading dictionaries: ${error.message}`;
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                dataDictionaryStatus.classList.add('text-red-600');
                console.error('Network error loading data dictionaries:', error);
            }
        }

        /**
         * Event listener for loading a selected data dictionary's content.
         * Fetches the file data and parses it as an Excel workbook.
         */
        loadDataDictionaryBtn.addEventListener('click', async () => {
            const selectedFileId = dataDictionarySelect.value;
            if (!selectedFileId) {
                dataDictionaryStatus.textContent = 'Please select a dictionary to load.';
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600');
                dataDictionaryStatus.classList.add('text-red-600');
                loadedDataDictionary = null; // Clear any previously loaded dictionary
                return;
            }

            dataDictionaryStatus.textContent = 'Loading dictionary content...';
            dataDictionaryStatus.classList.remove('hidden', 'text-red-600', 'text-green-600');
            dataDictionaryStatus.classList.add('text-gray-600');
            loadDataDictionaryBtn.disabled = true; // Disable button during load

            const token = localStorage.getItem('jwtToken');
            if (!token) {
                dataDictionaryStatus.textContent = 'Login required to load dictionary content.';
                dataDictionaryStatus.classList.add('text-red-600');
                loadDataDictionaryBtn.disabled = false;
                return;
            }

            try {
                // Fetch the binary content of the selected data dictionary file
                const response = await fetch(`/api/get-file?fileId=${selectedFileId}`, { // Use get-file to retrieve dictionary content
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json(); // Expecting JSON with fileData (base64)

                if (response.ok) {
                    // Decode base64 to binary string
                    const binaryString = atob(result.fileData);
                    // Convert binary string to Uint8Array
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    // Parse the binary Excel/CSV data using XLSX.js
                    const workbook = XLSX.read(bytes, { type: 'array', cellNF: true, cellDates: false });
                    
                    // Store the parsed workbook for later use by analyzeFile
                    loadedDataDictionary = workbook;
                    dataDictionaryStatus.textContent = `Dictionary "${result.filename}" loaded successfully!`;
                    dataDictionaryStatus.classList.remove('text-red-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-green-600');
                } else {
                    dataDictionaryStatus.textContent = `Error loading dictionary: ${result.message || 'Unknown error'}`;
                    dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-red-600');
                    loadedDataDictionary = null;
                    console.error('Error fetching data dictionary:', result.error || result.message);
                }
            } catch (error) {
                dataDictionaryStatus.textContent = `Network error loading dictionary: ${error.message}`;
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                dataDictionaryStatus.classList.add('text-red-600');
                loadedDataDictionary = null;
                console.error('Network error loading data dictionary:', error);
            } finally {
                loadDataDictionaryBtn.disabled = false; // Re-enable button
            }
        });

        /**
         * Updates the display element with the current date, used for future date flagging info.
         */
        function updateDynamicDateDisplay() {
            const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
            const dateElement = document.getElementById('dynamicTodayDate');
            if (dateElement) {
                dateElement.textContent = TODAY.toLocaleDateString('en-US', options);
            }
        }

        /**
         * Shows the loading spinner and hides results sections, resetting global state for a new analysis.
         */
        function showLoader() {
            document.getElementById('loader').style.display = 'block';
            document.getElementById('results').style.display = 'none';
            document.getElementById('summaryReportContainer').style.display = 'none';
            document.getElementById('generateSummaryBtn').style.display = 'none';
            document.getElementById('sheetResults').innerHTML = '';
            document.getElementById('fileName').textContent = '';
            
            // Reset all global data and stats for a fresh analysis
            workbookData = {};
            originalExcelWorkbook = null;
            overallStats = { blankCells: 0, nullValues: 0, futureDates: 0, duplicateRowCount: 0, totalProcessedDataCells: 0, totalRowsProcessedForDuplicates: 0 };
            hasDingedForHighPercentageCurrentFile = false;
            updateInitialOverallCountsDisplay(); // Clear display of previous overall counts
        }

        /**
         * Hides the loading spinner.
         */
        function hideLoader() {
            document.getElementById('loader').style.display = 'none';
        }
        
        /**
         * Updates the overall issue counts displayed prominently above the detailed sheet results.
         */
        function updateInitialOverallCountsDisplay() {
            document.getElementById('totalBlankCellsDisplay').textContent = `Overall Total Blank Cells (active): ${overallStats.blankCells}`;
            document.getElementById('totalNullCountDisplay').textContent = `Overall Total "NULL" Cells (active): ${overallStats.nullValues}`;
            document.getElementById('totalFutureDatesDisplay').textContent = `Overall Total Future Dates (active): ${overallStats.futureDates}`;
            document.getElementById('totalDuplicateRowsDisplay').textContent = `Overall Duplicate Rows Found: ${overallStats.duplicateRowCount}`;
        }
        
        /**
         * Renders the detailed analysis results for each worksheet and column into the UI.
         */
        function renderSheetResultsHTML() {
            const sheetResultsDiv = document.getElementById('sheetResults');
            sheetResultsDiv.innerHTML = ''; // Clear any previously rendered results
            
            Object.keys(workbookData).forEach(sheetName => {
                const sheetData = workbookData[sheetName];
                const sheetResultsContainer = document.createElement('div');
                sheetResultsContainer.classList.add('mb-8'); /* Add margin-bottom for spacing between sheets */
                sheetResultsContainer.innerHTML = `<h3 class="text-xl font-bold text-gray-800 mb-3">Sheet: ${sheetName}</h3>`; /* Styled heading */
                const columnsListUL = document.createElement('ul');
                columnsListUL.classList.add('space-y-4'); /* Add space between column list items */

                // Iterate through columns to render their specific issues and controls
                if (sheetData.columns && Object.keys(sheetData.columns).length > 0) {
                    Object.keys(sheetData.columns).forEach(columnName => {
                        const stats = sheetData.columns[columnName];
                        const listItem = document.createElement('li');
                        listItem.classList.add('p-3', 'bg-gray-50', 'rounded-lg', 'shadow-sm', 'border', 'border-gray-200'); /* Card-like style for each column */
                        
                        let issueDescriptions = [];
                        if (stats.blankCount > 0) issueDescriptions.push("blanks");
                        if (stats.nullStringCount > 0) issueDescriptions.push("NULLs");
                        if (stats.futureDateCount > 0) issueDescriptions.push("future dates");
                        
                        // Construct the descriptive text for column issues
                        let issueTextHTML = issueDescriptions.length > 0 ?
                            `<span class="text-red-600 font-semibold">Column "<strong>${columnName}</strong>" contains: ${issueDescriptions.join(', ')}.</span>` :
                            `<span class="text-green-600 font-semibold">Column "<strong>${columnName}</strong>" is clean.</span>`;
                        
                        // Sanitize column name for use in HTML IDs and data attributes (important for valid HTML)
                        const safeColumnName = columnName.replace(/[^a-zA-Z0-9]/g, "_");
                        const overrideCheckboxId = `override-${sheetName.replace(/[^a-zA-Z0-9]/g, "_")}-${safeColumnName}`;
                        
                        // Display individual issue counts (e.g., Blank=5 | NULL=2)
                        let countsDisplayParts = [];
                        if (stats.blankCount > 0) countsDisplayParts.push(`Blank=${stats.blankCount}`);
                        if (stats.nullStringCount > 0) countsDisplayParts.push(`NULL=${stats.nullStringCount}`);
                        if (stats.futureDateCount > 0) countsDisplayParts.push(`FutureDates=${stats.futureDateCount}`);
                        const countsDisplayHTML = countsDisplayParts.join(' | ');

                        // Build the HTML for each column's summary, including override checkbox and show/hide values button
                        listItem.innerHTML = `
                            <div class="flex flex-col md:flex-row md:items-center justify-between column-summary ${stats.isOverridden ? 'opacity-50 line-through' : ''}">
                                <div class="flex items-center mb-2 md:mb-0">
                                    <input type="checkbox" id="${overrideCheckboxId}" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 mr-2 override-checkbox" data-sheet="${sheetName}" data-column="${safeColumnName}" ${stats.isOverridden ? 'checked' : ''}>
                                    <label for="${overrideCheckboxId}" class="text-sm text-gray-700 mr-4">Override Issues</label>
                                    <span class="text-gray-900 text-base font-medium">${issueTextHTML}</span>
                                </div>
                                <div class="text-sm text-gray-600 italic">${countsDisplayHTML}</div>
                                <button class="ml-auto px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-md text-sm font-medium toggle-values-btn" data-sheet="${sheetName}" data-column="${safeColumnName}">Show Values</button>
                            </div>
                            <div class="column-values-container p-3 mt-3 bg-white border border-gray-300 rounded-lg shadow-inner" style="display:none; max-height: 250px; overflow-y: auto;"></div>
                        `;
                        columnsListUL.appendChild(listItem);
                    });
                } else {
                    const emptyColMsg = document.createElement('li');
                    emptyColMsg.textContent = "No columns found or processed for this sheet.";
                    emptyColMsg.classList.add('p-3', 'bg-gray-50', 'rounded-lg', 'text-gray-600');
                    columnsListUL.appendChild(emptyColMsg);
                }
                sheetResultsContainer.appendChild(columnsListUL);

                if (sheetData.duplicateInfo && sheetData.duplicateInfo.count > 0) {
                    const dupeInfoP = document.createElement('p');
                    dupeInfoP.classList.add('mt-4', 'text-gray-700', 'font-medium', 'text-center');
                    dupeInfoP.innerHTML = `<strong>Duplicate Rows Found in this sheet: ${sheetData.duplicateInfo.count}</strong> (see summary report for details)`;
                    sheetResultsContainer.appendChild(dupeInfoP);
                }
                sheetResultsDiv.appendChild(sheetResultsContainer);
            });
        }

        /**
         * Main function to analyze the uploaded Excel/CSV file.
         * It reads the file, parses it using XLSX.js, and detects various data quality issues.
         */
        function analyzeFile() {
            const fileInput = document.getElementById('excelFile');
            if (fileInput.files.length === 0) {
                alert("Please select a file to validate first.");
                return;
            }
            showLoader(); // Show loader and reset UI before processing
            const file = fileInput.files[0];
            currentFileName = file.name.replace(/\.(xlsx|xls|csv)$/i, '') + "_Reviewed.xlsx"; // Generate a name for the exported file
            document.getElementById('fileName').textContent = `File: ${file.name}`; // Display uploaded file name

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = new Uint8Array(event.target.result);
                    // Read Excel workbook using XLSX.js from ArrayBuffer
                    originalExcelWorkbook = XLSX.read(data, { type: 'array', cellNF: true, cellDates: false });
                    
                    document.getElementById('results').style.display = 'block'; // Show analysis results section
                    
                    overallStats.totalProcessedDataCells = 0; // Reset overall stats
                    overallStats.totalRowsProcessedForDuplicates = 0;

                    // Iterate through each sheet in the workbook
                    originalExcelWorkbook.SheetNames.forEach(sheetName => {
                        const worksheet = originalExcelWorkbook.Sheets[sheetName];
                        // Initialize data structure for the current sheet
                        workbookData[sheetName] = { columns: {}, duplicateInfo: { count: 0, rows: [] } };
                        
                        // Convert sheet to JSON array of arrays for easier processing, especially for duplicates
                        const jsonDataForDuplicates = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                        
                        // --- Duplicate Row Detection Logic ---
                        if (jsonDataForDuplicates.length > 0 || worksheet['!ref']) { // Check if sheet has data or is referenced
                            const seenRowStrings = new Map(); // To track seen row content
                            if (jsonDataForDuplicates.length > 1) { // Ensure there are data rows beyond header
                                overallStats.totalRowsProcessedForDuplicates += (jsonDataForDuplicates.length - 1); // Count data rows
                                for (let i = 1; i < jsonDataForDuplicates.length; i++) { // Iterate from the second row (assuming first is header)
                                    const currentRowData = jsonDataForDuplicates[i];
                                    // Create a consistent string representation of the row for uniqueness check (trim spaces, handle nulls)
                                    const rowString = currentRowData ? currentRowData.map(cell => cell === null || cell === undefined ? "" : String(cell).trim()).join('~!~') : null;
                                    
                                    if (rowString !== null) { // Only process if row has content
                                        if (seenRowStrings.has(rowString)) { // If this row content has been seen before
                                            const firstSeenJsonIndex = seenRowStrings.get(rowString);
                                            // Check if this exact duplicate instance is already recorded
                                            const alreadyRecorded = workbookData[sheetName].duplicateInfo.rows.some(r => r.originalRowIndex === (i + 1) && !r.isFirstOccurrence);
                                            
                                            if (!alreadyRecorded) {
                                                workbookData[sheetName].duplicateInfo.count++; // Increment sheet-specific duplicate count
                                                overallStats.duplicateRowCount++; // Increment global duplicate count
                                                workbookData[sheetName].duplicateInfo.rows.push({
                                                    originalRowIndex: i + 1, // Store Excel row number (1-indexed)
                                                    isFirstOccurrence: false,
                                                    duplicateOf: firstSeenJsonIndex + 1, // Row number of its first occurrence
                                                    data: currentRowData // Store raw row data for sample display in report
                                                });
                                                // Also ensure the *first* occurrence of this duplicate set is recorded
                                                if (!workbookData[sheetName].duplicateInfo.rows.find(r => r.originalRowIndex === (firstSeenJsonIndex + 1))) {
                                                    workbookData[sheetName].duplicateInfo.rows.push({
                                                        originalRowIndex: firstSeenJsonIndex + 1,
                                                        isFirstOccurrence: true,
                                                        duplicateOf: null,
                                                        data: jsonDataForDuplicates[firstSeenJsonIndex]
                                                    });
                                                }
                                            }
                                        } else {
                                            seenRowStrings.set(rowString, i); // Record index of first occurrence
                                        }
                                    }
                                }
                            }
                        }

                        // --- Column-level Issue Detection (Blanks, "NULL" strings, Future Dates) ---
                        const headers = jsonDataForDuplicates[0] || []; // Get headers (first row data)
                        const sheetColumnStats = {};
                        const range = XLSX.utils.decode_range(worksheet['!ref'] || "A1:A1"); // Get actual used range of sheet (e.g., A1:C5)
                        // Determine the maximum number of columns to iterate through based on headers or actual range
                        const maxCols = (headers.length > 0) ? headers.length : (range.e.c + 1);

                        // Initialize stats for each detected column
                        for (let C = 0; C < maxCols; C++) {
                            const columnName = (headers[C] !== null && headers[C] !== undefined) ? String(headers[C]) : `Column ${XLSX.utils.encode_col(C)}`; // Default to "Column A", "Column B" etc.
                            sheetColumnStats[columnName] = { blankCount: 0, nullStringCount: 0, futureDateCount: 0, hasIssue: false, values: [], isOverridden: false };
                        }
                        
                        const actualHeaderKeys = Object.keys(sheetColumnStats); // Get actual column names for iteration

                        // Calculate total processed cells for overall clean rate (excluding header row)
                        if (range.e.r >= range.s.r + 1 && actualHeaderKeys.length > 0) {
                            overallStats.totalProcessedDataCells += (range.e.r - range.s.r) * actualHeaderKeys.length;
                        }

                        // Iterate through cells of the current sheet and collect stats
                        for (let R = range.s.r + 1; R <= range.e.r; ++R) { // Start from the second row (data rows)
                            for (let C = range.s.c; C <= Math.min(range.e.c, maxCols - 1); ++C) { // Iterate up to the determined maxCols
                                const cellAddress = XLSX.utils.encode_cell({ r: R, c: C }); // Get Excel cell address (e.g., A2, B5)
                                const cell = worksheet[cellAddress]; // Get cell object from worksheet
                                let cellValueToStore = cell ? cell.v : null; // Raw value from XLSX.js cell object
                                let processedCellValue = cellValueToStore; // Value potentially processed for type (e.g., Date object)
                                const columnName = actualHeaderKeys[C]; // Get the column's header name

                                if (!columnName) continue;

                                // Special handling for dates to convert Excel's numeric date to JavaScript Date object
                                if (cell && cell.t === 'n' && cell.z && XLSX.SSF.is_date(cell.z)) {
                                    const dateInfo = XLSX.SSF.parse_date_code(cell.v);
                                    if (dateInfo) {
                                        // Create UTC Date object to avoid timezone issues during comparison
                                        processedCellValue = new Date(Date.UTC(dateInfo.y, dateInfo.m - 1, dateInfo.d, dateInfo.H || 0, dateInfo.M || 0, dateInfo.S || 0));
                                        cellValueToStore = processedCellValue;
                                    } else {
                                        processedCellValue = cell.v;
                                    }
                                }

                                // Store the value along with its original row number for display
                                sheetColumnStats[columnName].values.push({ value: cellValueToStore, originalDataRow: R });

                                // Perform issue checks
                                if (processedCellValue instanceof Date && !isNaN(processedCellValue.getTime())) {
                                    // Normalize cell date to UTC midnight for comparison with TODAY
                                    const cellDateOnly = new Date(Date.UTC(processedCellValue.getUTCFullYear(), processedCellValue.getUTCMonth(), processedCellValue.getUTCDate()));
                                    if (cellDateOnly > TODAY) { // Check if date is in the future
                                        sheetColumnStats[columnName].futureDateCount++;
                                        sheetColumnStats[columnName].hasIssue = true;
                                    }
                                } else if (processedCellValue !== null && processedCellValue !== undefined && String(processedCellValue).trim().toUpperCase() === "NULL") {
                                    // Check for the string "NULL" (case-insensitive, trimmed)
                                    sheetColumnStats[columnName].nullStringCount++;
                                    sheetColumnStats[columnName].hasIssue = true;
                                } else if (processedCellValue === null || String(processedCellValue).trim() === "") {
                                    // Check for truly blank cells (null or empty string after trimming)
                                    sheetColumnStats[columnName].blankCount++;
                                    sheetColumnStats[columnName].hasIssue = true;
                                }
                            }
                        }
                        workbookData[sheetName].columns = sheetColumnStats; // Store collected column stats
                    });
                    
                    recalculateGlobalOverallStatsFromWorkbookData(); // Update global stats based on all sheets
                    renderSheetResultsHTML(); // Render the initial analysis results in the UI
                    updateInitialOverallCountsDisplay(); // Update the prominent overall counts
                    document.getElementById('generateSummaryBtn').style.display = 'inline-block'; // Show the "View Summary Report" button
                } catch (error) {
                    console.error("Error processing file:", error);
                    document.getElementById('sheetResults').innerHTML = `<p class="text-red-600">Error processing file: ${error.message}. Make sure it's a valid Excel/CSV file.</p>`;
                    updateInitialOverallCountsDisplay();
                } finally {
                    hideLoader();
                }
            };
            reader.readAsArrayBuffer(file); // Start reading the file as an ArrayBuffer
        }
        
        /**
         * Generates and displays the comprehensive summary report in a separate section.
         * This report is also the basis for the Excel export.
         * @param {boolean} shouldScrollToReport - If true, the page will scroll to the report section.
         */
        function generateSummaryReport(shouldScrollToReport = true) {
            const summaryContainer = document.getElementById('summaryReportContainer');
            summaryContainer.innerHTML = ''; // Clear previous report content
            recalculateGlobalOverallStatsFromWorkbookData(); // Ensure global stats are up-to-date with overrides

            // Calculate overall data quality metrics
            const totalCellLevelIssues = overallStats.blankCells + overallStats.nullValues + overallStats.futureDates;
            const totalEffectiveIssues = totalCellLevelIssues + overallStats.duplicateRowCount;
            // Denominator for issue rate, ensuring no division by zero
            const issueRateDenominator = (overallStats.totalProcessedDataCells + overallStats.totalRowsProcessedForDuplicates) || 1;
            const issueRate = (totalEffectiveIssues / issueRateDenominator) * 100;
            const cleanRate = Math.max(0, 100 - issueRate); // Clean rate cannot be negative
            const passFailStatus = cleanRate >= CLEAN_RATE_PASS_THRESHOLD ? "Pass" : "Fail";
            const passFailClass = passFailStatus === "Pass" ? "text-green-600" : "text-red-600";

            // Play a success sound if clean rate meets threshold and hasn't played for this file yet
            if (passFailStatus === "Pass" && !hasDingedForHighPercentageCurrentFile) {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.speak(new SpeechSynthesisUtterance("Validation passed"));
                }
                hasDingedForHighPercentageCurrentFile = true;
            } else if (passFailStatus === "Fail") {
                hasDingedForHighPercentageCurrentFile = false; // Reset flag if validation fails
            }

            // Build the HTML for the overall statistics summary section
            let reportHTML = `<h1 class="text-2xl font-bold text-blue-700 mb-4 text-center">Data Quality Summary Report</h1><div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h2>Overall Statistics (Column Issue Overrides Applied)</h2>`;
            reportHTML += `<p class="text-gray-700"><strong>File:</strong> ${document.getElementById('fileName').textContent.replace('File: ', '')}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Processed Data Cells:</strong> ${overallStats.totalProcessedDataCells}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Rows Processed (for duplicates):</strong> ${overallStats.totalRowsProcessedForDuplicates}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Blank Cells (effective):</strong> ${overallStats.blankCells}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total "NULL" Cells (effective):</strong> ${overallStats.nullValues}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Future Dates (effective):</strong> ${overallStats.futureDates}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Duplicate Rows Found:</strong> ${overallStats.duplicateRowCount}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Cell-Level Issues (effective):</strong> ${totalCellLevelIssues}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Total Effective Issues (Cells + Duplicates):</strong> ${totalEffectiveIssues}</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Issue Rate (approximate):</strong> ${issueRate.toFixed(2)}%</p>`;
            reportHTML += `<p class="text-gray-700"><strong>Clean Rate (approximate):</strong> ${cleanRate.toFixed(2)}%</p>`;
            reportHTML += `<p class="text-lg font-semibold mt-4"><strong>Status: <span class="${passFailClass}">${passFailStatus}</span></strong> (Threshold: ${CLEAN_RATE_PASS_THRESHOLD}% clean)</p></div>`;
            
            reportHTML += `<div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h2>Detailed Issues by Column (Raw Counts)</h2><table class="w-full text-left table-auto border-collapse"><thead><tr class="bg-gray-200"><th>Sheet</th><th>Column</th><th>Blanks</th><th>NULLs</th><th>Future Dates</th><th>Overridden</th></tr></thead><tbody>`;
            
            let issuesFoundDetails = false;
            Object.keys(workbookData).forEach(sheetName => {
                const sheetColData = workbookData[sheetName].columns;
                if (sheetColData) {
                    Object.keys(sheetColData).forEach(columnName => {
                        const stats = sheetColData[columnName];
                        if (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0 || stats.isOverridden) {
                            issuesFoundDetails = true;
                            const safeColName = columnName.replace(/[^a-zA-Z0-9]/g, "_");
                            const overriddenMarker = stats.isOverridden ? ' <span class="text-gray-500 text-xs italic">(Overridden)</span>' : '';
                            const overriddenClass = stats.isOverridden ? 'opacity-50 line-through' : '';
                            reportHTML += `<tr class="border-b border-gray-200"><td>${sheetName}</td><td>${columnName}${overriddenMarker}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="blankCount">${stats.blankCount}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="nullStringCount">${stats.nullStringCount}</td><td contenteditable="true" class="p-2 bg-yellow-50 rounded ${overriddenClass}" data-sheet="${sheetName}" data-column="${safeColName}" data-type="futureDateCount">${stats.futureDateCount}</td><td>${stats.isOverridden ? "Yes" : "No"}</td></tr>`;
                        }
                    });
                }
            });
            if (!issuesFoundDetails) reportHTML += `<tr><td colspan="6" class="text-center text-gray-500 py-4">No specific column issues found or overridden.</td></tr>`;
            reportHTML += `</tbody></table></div>`;

            reportHTML += `<div class="bg-gray-50 p-6 rounded-lg shadow-sm mb-6"><h3>Duplicate Row Details</h3><table class="w-full text-left table-auto border-collapse"><thead><tr class="bg-gray-200"><th>Sheet</th><th>Duplicate Row #</th><th>First Seen At Row #</th><th>Sample Data (First 3 Cells)</th></tr></thead><tbody>`;
            
            let duplicatesListed = false;
            Object.keys(workbookData).forEach(sheetName => {
                const { duplicateInfo } = workbookData[sheetName];
                if (duplicateInfo && duplicateInfo.rows) {
                    const sortedDuplicates = [...duplicateInfo.rows].sort((a, b) => {
                        if (a.originalRowIndex !== b.originalRowIndex) {
                            return a.originalRowIndex - b.originalRowIndex;
                        }
                        return a.isFirstOccurrence ? -1 : 1;
                    });

                    sortedDuplicates.forEach(dupeRow => {
                        if (!dupeRow.isFirstOccurrence) {
                            duplicatesListed = true;
                            const sample = dupeRow.data.slice(0, 3).map(d => {
                                if (d === null || d === undefined) return "";
                                if (d instanceof Date) return d.toLocaleDateString('en-US', {timeZone: 'UTC'});
                                return String(d);
                            }).join(', ');
                            reportHTML += `<tr class="border-b border-gray-200"><td>${sheetName}</td><td>${dupeRow.originalRowIndex}</td><td>${dupeRow.duplicateOf}</td><td>${sample}...</td></tr>`;
                        }
                    });
                }
            });
            if (!duplicatesListed) reportHTML += `<tr><td colspan="4" class="text-center text-gray-500 py-4">No duplicate rows found.</td></tr>`;
            reportHTML += `</tbody></table></div>`;

            reportHTML += `<div class="flex justify-center space-x-4 print-hidden">`;
            reportHTML += `<button id="printSummaryBtn" onclick="window.print()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-300">Print Report</button>`;
            reportHTML += `<button id="exportExcelBtn" onclick="exportExcelWithSummary()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-300">Export Excel w/ Summary</button>`;
            reportHTML += `</div>`;
            
            summaryContainer.innerHTML = reportHTML;
            summaryContainer.style.display = 'block';
            if (shouldScrollToReport) summaryContainer.scrollIntoView({ behavior: 'smooth' });
        }

        document.getElementById('sheetResults').addEventListener('click', function(event) {
            const target = event.target;
            if (target.classList.contains('override-checkbox')) {
                const { sheet, column } = target.dataset;
                const originalColName = findOriginalColumnName(sheet, column);
                if (workbookData[sheet]?.columns?.[originalColName]) {
                    workbookData[sheet].columns[originalColName].isOverridden = target.checked;
                    target.closest('.column-summary').classList.toggle('opacity-50', target.checked);
                    target.closest('.column-summary').classList.toggle('line-through', target.checked);
                    recalculateGlobalOverallStatsFromWorkbookData();
                    updateInitialOverallCountsDisplay();
                    if (document.getElementById('summaryReportContainer').style.display !== 'none') {
                        generateSummaryReport(false);
                    }
                }
            } else if (target.classList.contains('toggle-values-btn')) {
                const { sheet, column } = target.dataset;
                const originalColName = findOriginalColumnName(sheet, column);
                const valuesContainer = target.closest('li').querySelector('.column-values-container');
                if (!workbookData[sheet]?.columns?.[originalColName]) {
                    console.error("Data not found for:", sheet, originalColName);
                    return;
                }
                if (valuesContainer.style.display === 'none') {
                    valuesContainer.innerHTML = '';
                    const stats = workbookData[sheet].columns[originalColName];
                    const sortableValues = stats.values.map(item => {
                        const val = item.value;
                        const stringValue = (val === null || val === undefined) ? "" : String(val).trim();
                        const isFuture = (val instanceof Date && !isNaN(val.getTime()) && new Date(Date.UTC(val.getUTCFullYear(), val.getUTCMonth(), val.getUTCDate())) > TODAY);
                        const isBlank = (val === null || stringValue === "");
                        const isNullString = (val !== null && val !== undefined && stringValue.toUpperCase() === "NULL");
                        const isInvalidDate = (val instanceof Date && isNaN(val.getTime()));
                        const hasAnyIssue = isFuture || isBlank || isNullString || isInvalidDate;
                        return { ...item, value: val, isFuture, isBlank, isNullString, isInvalidDate, hasAnyIssue };
                    });
                    sortableValues.sort((a, b) => (a.hasAnyIssue === b.hasAnyIssue) ? a.originalDataRow - b.originalDataRow : a.hasAnyIssue ? -1 : 1);

                    if (sortableValues.length > 0) {
                        const ul = document.createElement('ul');
                        ul.classList.add('space-y-1');
                        sortableValues.forEach(item => {
                            const { value, originalDataRow } = item;
                            const li = document.createElement('li');
                            let displayValue;
                            let valueClass = '';

                            if (item.isFuture) { valueClass = 'text-red-500 font-bold'; displayValue = `Row ${originalDataRow + 1}: Future Date - ${value.toLocaleDateString('en-US', {timeZone: 'UTC'})}`; }
                            else if (item.isBlank) { valueClass = 'text-orange-500 italic'; displayValue = `Row ${originalDataRow + 1}: Blank Cell (${value === null ? 'null' : 'empty string'})`; }
                            else if (item.isNullString) { valueClass = 'text-red-500 italic'; displayValue = `Row ${originalDataRow + 1}: NULL String Issue - "${value}"`; }
                            else if (item.isInvalidDate) { valueClass = 'text-red-500 italic'; displayValue = `Row ${originalDataRow + 1}: Invalid Date Object - "${String(value)}"`; }
                            else if (value instanceof Date) { valueClass = 'text-blue-600'; displayValue = `Row ${originalDataRow + 1}: ${value.toLocaleDateString('en-US', {timeZone: 'UTC'})}`; }
                            else if (typeof value === 'object' && value !== null) { try { displayValue = `Row ${originalDataRow + 1}: Value: ${JSON.stringify(value)}`; } catch (e) { displayValue = `Row ${originalDataRow + 1}: Value: [Object]`; } }
                            else { displayValue = `Row ${originalDataRow + 1}: Value: ${value}`; }

                            li.textContent = displayValue;
                            if (valueClass) li.classList.add(valueClass);
                            else if(item.hasAnyIssue) li.classList.add('text-orange-600', 'font-bold');
                            ul.appendChild(li);
                        });
                        valuesContainer.appendChild(ul);
                    } else {
                        valuesContainer.innerHTML = '<p class="text-gray-500 italic">This column has no data rows.</p>';
                    }
                    valuesContainer.style.display = 'block';
                    target.textContent = 'Hide Values';
                } else {
                    valuesContainer.style.display = 'none';
                    valuesContainer.innerHTML = '';
                    target.textContent = 'Show Values';
                }
            }
        });

        function findOriginalColumnName(sheet, colFromDataset) {
            const cols = workbookData[sheet]?.columns;
            if (!cols) return colFromDataset;
            if (cols[colFromDataset]) return colFromDataset;
            return Object.keys(cols).find(k => k.replace(/[^a-zA-Z0-9]/g, "_") === colFromDataset) || colFromDataset;
        }

        function recalculateGlobalOverallStatsFromWorkbookData() {
            let newBlank = 0, newNull = 0, newFuture = 0;
            Object.values(workbookData).forEach(({ columns }) => {
                if(columns) Object.values(columns).forEach(stats => {
                    if (!stats.isOverridden) {
                        newBlank += parseInt(stats.blankCount, 10) || 0;
                        newNull += parseInt(stats.nullStringCount, 10) || 0;
                        newFuture += parseInt(stats.futureDateCount, 10) || 0;
                    }
                });
            });
            overallStats.blankCells = newBlank;
            overallStats.nullValues = newNull;
            overallStats.futureDates = newFuture;
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('summaryReportContainer')?.addEventListener('blur', function(event) {
                if (event.target.classList.contains('editable-stat')) {
                    const td = event.target;
                    const { sheet, column, type } = td.dataset;
                    const originalColName = findOriginalColumnName(sheet, column);
                    const newValue = parseInt(td.textContent.trim(), 10);

                    if (workbookData[sheet]?.columns?.[originalColName]) {
                        const stats = workbookData[sheet].columns[originalColName];
                        if (isNaN(newValue) || newValue < 0 || td.textContent.trim() === "") {
                            alert("Please enter a valid non-negative number.");
                            td.textContent = stats[type];
                            return;
                        }
                        stats[type] = newValue;
                        stats.hasIssue = (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0); 
                        recalculateGlobalOverallStatsFromWorkbookData();
                        if (document.getElementById('summaryReportContainer').style.display !== 'none') {
                            generateSummaryReport(false);
                        } else {
                            updateInitialOverallCountsDisplay();
                        }
                    } else {
                        console.error("Editable cell event: Could not find column data for update:", sheet, originalColName);
                    }
                }
            }, true);
        });

        function exportExcelWithSummary() {
            if (!originalExcelWorkbook) {
                alert("Please analyze a file first to generate data for export.");
                return;
            }
            recalculateGlobalOverallStatsFromWorkbookData();

            const wb = XLSX.utils.book_new();

            originalExcelWorkbook.SheetNames.forEach(sheetName => {
                const sheetData = XLSX.utils.sheet_to_json(originalExcelWorkbook.Sheets[sheetName], {header:1, defval:null});
                XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(sheetData), sheetName);
            });

            const summaryAoA = [];
            const { blankCells, nullValues, futureDates, duplicateRowCount, totalProcessedDataCells, totalRowsProcessedForDuplicates } = overallStats;
            const totalCellIssues = blankCells + nullValues + futureDates;
            const totalEffectiveIssues = totalCellIssues + duplicateRowCount;
            const denominator = (totalProcessedDataCells + totalRowsProcessedForDuplicates) || 1;
            const issueRate = (totalEffectiveIssues / denominator) * 100;
            const cleanRate = Math.max(0, 100 - issueRate);
            const status = cleanRate >= CLEAN_RATE_PASS_THRESHOLD ? "Pass" : "Fail";

            summaryAoA.push(["Data Quality Summary Report"]);
            summaryAoA.push([]);
            summaryAoA.push(["Overall Statistics"]);
            summaryAoA.push(["File:", document.getElementById('fileName').textContent.replace('File: ', '')]);
            summaryAoA.push(["Total Processed Data Cells:", totalProcessedDataCells]);
            summaryAoA.push(["Total Rows Processed (for duplicates):", totalRowsProcessedForDuplicates]);
            summaryAoA.push(["Total Blank Cells (effective):", blankCells]);
            summaryAoA.push(["Total \"NULL\" Cells (effective):", nullValues]);
            summaryAoA.push(["Total Future Dates (effective):", futureDates]);
            summaryAoA.push(["Total Duplicate Rows Found:", duplicateRowCount]);
            summaryAoA.push(["Total Cell-Level Issues (effective):", totalCellIssues]);
            summaryAoA.push(["Total Effective Issues (Cells + Duplicates):", totalEffectiveIssues]);
            summaryAoA.push(["Issue Rate (approximate):", `${issueRate.toFixed(2)}%`]);
            summaryAoA.push(["Clean Rate (approximate):", `${cleanRate.toFixed(2)}%`]);
            summaryAoA.push(["Status:", `${status} (Threshold: ${CLEAN_RATE_PASS_THRESHOLD}% clean)`]);
            summaryAoA.push([]);

            summaryAoA.push(["Detailed Issues by Column (Raw Counts)"]);
            summaryAoA.push(["Sheet", "Column", "Blanks", "NULLs", "Future Dates", "Overridden"]);
            
            let detailsAdded = false;
            Object.entries(workbookData).forEach(([sheetName, { columns }]) => {
                if (columns) {
                    Object.entries(columns).forEach(([columnName, stats]) => {
                        if (stats.blankCount > 0 || stats.nullStringCount > 0 || stats.futureDateCount > 0 || stats.isOverridden) {
                            detailsAdded = true;
                            summaryAoA.push([sheetName, columnName, stats.blankCount, stats.nullStringCount, stats.futureDateCount, stats.isOverridden ? "Yes" : "No"]);
                        }
                    });
                }
            });
            if (!detailsAdded) summaryAoA.push(["No columns with issues or overrides to report."]);
            summaryAoA.push([]);

            summaryAoA.push(["Duplicate Row Details"]);
            summaryAoA.push(["Sheet", "Duplicate Row #", "First Seen At Row #", "Sample Data (First 3 Cells)"]);
            
            let duplicatesExported = false;
            Object.entries(workbookData).forEach(([sheetName, { duplicateInfo }]) => {
                if (duplicateInfo && duplicateInfo.rows) {
                    const duplicatesToExport = duplicateInfo.rows.filter(dupe => !dupe.isFirstOccurrence).sort((a, b) => a.originalRowIndex - b.originalRowIndex);

                    duplicatesToExport.forEach(dupe => {
                        duplicatesExported = true;
                        const sample = dupe.data.slice(0, 3).map(d => {
                            if (d === null || d === undefined) return "";
                            if (d instanceof Date) return d.toLocaleDateString('en-US', {timeZone: 'UTC'});
                            return String(d);
                        }).join(', ');
                        summaryAoA.push([sheetName, dupe.originalRowIndex, dupe.duplicateOf, `${sample}...`]);
                    });
                }
            });
            if (!duplicatesExported) summaryAoA.push(["No duplicate rows found."]);

            const summaryWS = XLSX.utils.aoa_to_sheet(summaryAoA);
            XLSX.utils.book_append_sheet(wb, summaryWS, "Summary Report");

            XLSX.writeFile(wb, currentFileName);
        }
    </script>
</body>
</html>
```
I understand you're pointing to the code within the `file-manager-frontend` Canvas and asking for the next step.

The current `file-manager.html` code you provided is up-to-date with defensive parsing for filenames and displays the "Data Dictionary" tag.

The next step is to **update your `public/tools/validation-engine.html` file** to incorporate the data dictionary selection. This will allow users to choose an uploaded data dictionary and load its rules for validation.

Here is the updated code for your `public/tools/validation-engine.html` file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Validate - MirraBuddy</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- XLSX library for client-side Excel file parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
        }
        /* Loader Animation - specific CSS needed for animation */
        .loader {
            border: 6px solid #e9ecef;
            border-top: 6px solid #2D62B3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            display: none; /* Hidden by default */
            margin: 25px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Specific print styles to hide UI elements */
        @media print {
            body { background-color: #fff; }
            body * { visibility: hidden; }
            #summaryReportContainer, #summaryReportContainer * { visibility: visible; }
            #summaryReportContainer { position: absolute; left: 0; top: 0; width: 100%; border: none !important; box-shadow: none !important; margin:0 !important; padding:0 !important; border-radius: 0; }
            .print-hidden { display: none !important; } /* Class to hide elements specifically when printing */
            #summaryReportContainer h1, #summaryReportContainer h2, #summaryReportContainer h3, #summaryReportContainer h4 { color: black !important; border: none !important; }
            #summaryReportContainer table, #summaryReportContainer th, #summaryReportContainer td { border: 1px solid #666 !important; }
            #summaryReportContainer th { background-color: #eee !important; }
            a { text-decoration: none; color: black !important; }
            .pass-status { color: #006400 !important; }
            .fail-status { color: #8B0000 !important; }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen text-gray-800">
    <!-- Header Section: Consistent navigation across the app -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 p-4 shadow-lg print-hidden">
        <div class="container mx-auto flex flex-col sm:flex-row items-center justify-between">
            <h1 class="text-white text-3xl font-bold mb-2 sm:mb-0">Excel Validate</h1>
            <nav>
                <ul class="flex space-x-4">
                    <li><a href="/dashboard.html" class="text-white hover:text-blue-200 transition duration-300">Dashboard</a></li>
                    <li><a href="/tools.html" class="text-white hover:text-blue-200 transition duration-300">Tools List</a></li>
                    <li><a href="/tools/data-cleaner.html" class="text-white hover:text-blue-200 transition duration-300">Data Cleaner</a></li>
                    <li><a href="/tools/validation-engine.html" class="text-white hover:text-blue-200 transition duration-300 active">Excel Validate</a></li>
                    <li><a href="#" id="profileLink" class="text-white hover:text-blue-200 transition duration-300">Profile</a></li>
                    <li><a href="#" id="logoutBtn" class="text-white hover:text-blue-200 transition duration-300 cursor-pointer">Logout</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content Section: Central area for the tool's functionality -->
    <main class="flex-grow container mx-auto p-4 sm:p-6 lg:p-8">
        <section class="bg-white p-6 sm:p-8 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl sm:text-3xl font-semibold text-center text-blue-700 mb-4">
                Validate Your Excel Data Against Custom Rules
            </h2>
            <p class="text-lg text-gray-700 text-center mb-6">
                Ensure the integrity and accuracy of your spreadsheets by setting up and running powerful validation rules.
            </p>
            <div class="max-w-xl mx-auto text-gray-600 text-base mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
                <p class="font-semibold text-gray-800 mb-2">About This Tool:</p>
                <p>The **Validation Engine** helps you define and enforce data quality standards for your Excel files. It performs a comprehensive analysis of your data to identify common issues such as blank cells, "NULL" string entries, and dates that fall in the future. Additionally, it identifies duplicate rows within your sheets, ensuring data uniqueness. You can selectively ignore ("override") specific column issues from the overall Pass/Fail calculation in the summary report. This tool is ideal for pre-processing data for analysis, reporting, or database imports, ensuring your datasets are clean and reliable.</p>
                <ul class="list-disc list-inside mt-3 ml-5">
                    <li>**Blank Cells:** Detects and counts empty cells.</li>
                    <li>**"NULL" Strings:** Flags cells containing the literal string "NULL" (case-insensitive).</li>
                    <li>**Future Dates:** Identifies dates that are set after today's date.</li>
                    <li>**Duplicate Rows:** Pinpoints entire rows that are identical, indicating redundant entries.</li>
                    <li>**Override Issues:** Allows you to exclude specific column issues from the final data quality score if they are intentional.</li>
                </ul>
                <p class="mt-3">Upload your file, review the real-time analysis results, override irrelevant issues, and generate a detailed summary report. You can then print the report or export it along with your original data to a new Excel file.</p>
            </div>

            <div class="max-w-xl mx-auto bg-green-50 p-6 rounded-lg shadow-md border border-green-200">
                <h3 class="text-xl font-bold text-green-600 mb-4">Upload File & Analyze</h3>
                <form id="analyzeForm" class="space-y-4">
                    <div>
                        <label for="excelFile" class="block text-sm font-medium text-gray-700">Select Excel or CSV File to Validate</label>
                        <input type="file" id="excelFile" accept=".xlsx, .xls, .csv" required
                               class="mt-1 block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-white focus:outline-none focus:border-green-500">
                    </div>

                    {/* Data Dictionary Selection */}
                    <div class="border-t border-gray-200 pt-4">
                        <h4 class="text-lg font-bold text-gray-700 mb-2">Optional: Select a Data Dictionary</h4>
                        <p class="text-sm text-gray-600 mb-3">Choose an uploaded data dictionary to use its rules for validation.</p>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <select id="dataDictionarySelect" class="flex-grow p-2 border border-gray-300 rounded-lg bg-white focus:ring-blue-500 focus:border-blue-500">
                                <option value="">-- No Data Dictionary Selected --</option>
                                {/* Options will be loaded here by JavaScript */}
                            </select>
                            <button type="button" id="loadDataDictionaryBtn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm transition duration-300">Load Dictionary</button>
                        </div>
                        <div id="dataDictionaryStatus" class="mt-2 text-sm text-gray-600 hidden"></div>
                    </div>
                    {/* End Data Dictionary Selection */}

                    <button type="button" id="analyzeFileBtn" onclick="analyzeFile()"
                            class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-lg text-lg font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-300 ease-in-out transform hover:-translate-y-0.5">
                        Analyze File
                    </button>
                </form>

                <div class="loader" id="loader"></div>

                <div id="results" class="mt-8 hidden">
                    <h2 class="text-xl font-bold text-gray-800 mb-4">Analysis Results</h2>
                    <p id="fileName" class="text-gray-700 font-medium mb-4"></p>
                    <div id="overallCounts" class="bg-gray-100 p-4 rounded-lg shadow-inner mb-6">
                        <p id="totalBlankCellsDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalNullCountDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalFutureDatesDisplay" class="text-gray-800 text-base font-medium"></p>
                        <p id="totalDuplicateRowsDisplay" class="text-gray-800 text-base font-medium"></p>
                    </div>
                    <div id="sheetResults"></div>
                    <button id="generateSummaryBtn" onclick="generateSummaryReport()" class="mt-6 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition duration-300 hidden">View Summary Report</button>
                </div>
            </div>

            <div id="summaryReportContainer" class="content-box mt-8" style="display:none;">
            </div>
        </section>
    </main>

    <!-- Footer Section -->
    <footer class="bg-gray-800 text-white p-4 mt-8 print-hidden">
        <div class="container mx-auto text-center text-sm">
            &copy; 2025 Excel Buddy. All rights reserved.
        </div>
    </footer>

    <script>
        // --- Authentication Check and Logout Functionality (Adapted for consistency with existing project) ---
        document.addEventListener('DOMContentLoaded', async () => {
            const token = localStorage.getItem('jwtToken');
            if (!token) {
                window.location.href = '/'; // Redirects to index.html
                return;
            }
            try {
                const response = await fetch('/api/protected', {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) {
                    localStorage.removeItem('jwtToken');
                    window.location.href = '/';
                } else {
                    updateDynamicDateDisplay();
                    loadDataDictionaries(); // Call to load data dictionaries on successful auth
                }
            } catch (error) {
                console.error('Error verifying token on Validation Engine page:', error);
                localStorage.removeItem('jwtToken');
                window.location.href = '/';
            }
        });

        const logoutButton = document.getElementById('logoutBtn');
        if (logoutButton) {
            logoutButton.addEventListener('click', function() {
                localStorage.removeItem('jwtToken');
                window.location.href = '/';
            });
        }
        // --- End of Authentication consistency adaptation ---


        let workbookData = {}; // Stores all parsed data and analysis results
        let originalExcelWorkbook = null; // Stores the original XLSX.js workbook object
        let currentFileName = "ReviewedData.xlsx"; // Default filename for export
        // Overall statistics, dynamically updated based on user overrides
        let overallStats = { blankCells: 0, nullValues: 0, futureDates: 0, duplicateRowCount: 0, totalProcessedDataCells: 0, totalRowsProcessedForDuplicates: 0 };
        const TODAY = new Date();
        TODAY.setUTCHours(0, 0, 0, 0); // Normalize today's date to UTC midnight for consistent date comparisons
        const CLEAN_RATE_PASS_THRESHOLD = 95; // Threshold for "Pass" status in clean rate
        let hasDingedForHighPercentageCurrentFile = false; // Flag to prevent repeated speech notifications
        let loadedDataDictionary = null; // To store the content of the loaded data dictionary workbook

        // --- DOM Elements for Data Dictionary Selection ---
        const dataDictionarySelect = document.getElementById('dataDictionarySelect');
        const loadDataDictionaryBtn = document.getElementById('loadDataDictionaryBtn');
        const dataDictionaryStatus = document.getElementById('dataDictionaryStatus');

        /**
         * Loads data dictionary files from the backend (File Manager's list-files endpoint)
         * and populates the dropdown. Filters for files marked as is_data_dictionary.
         */
        async function loadDataDictionaries() {
            dataDictionarySelect.innerHTML = '<option value="">-- Loading Dictionaries... --</option>'; // Initial loading state
            const token = localStorage.getItem('jwtToken');
            if (!token) {
                dataDictionarySelect.innerHTML = '<option value="">-- Login to Load Dictionaries --</option>';
                return;
            }

            try {
                // Fetch files from /api/list-files. We'll filter for data dictionaries on the frontend for now.
                // A future enhancement could be to add a query parameter to list-files.js
                const response = await fetch('/api/list-files', {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json();

                if (response.ok && result.files) {
                    // Filter files to only include those marked as data dictionaries
                    const dataDictionaries = result.files.filter(file => file.is_data_dictionary);

                    dataDictionarySelect.innerHTML = '<option value="">-- No Data Dictionary Selected --</option>'; // Reset dropdown
                    dataDictionaries.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file.id; // Use file ID as the option value
                        option.textContent = file.filename; // Display filename
                        dataDictionarySelect.appendChild(option);
                    });

                    if (dataDictionaries.length > 0) {
                        dataDictionaryStatus.textContent = `Loaded ${dataDictionaries.length} dictionaries.`;
                        dataDictionaryStatus.classList.remove('hidden', 'text-red-600');
                        dataDictionaryStatus.classList.add('text-green-600');
                    } else {
                        dataDictionaryStatus.textContent = `No data dictionaries uploaded for your company.`;
                        dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-red-600');
                        dataDictionaryStatus.classList.add('text-gray-600');
                    }
                } else {
                    dataDictionarySelect.innerHTML = '<option value="">-- Error Loading Dictionaries --</option>';
                    dataDictionaryStatus.textContent = `Error loading dictionaries: ${result.message || 'Unknown error'}`;
                    dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                    dataDictionaryStatus.classList.add('text-red-600');
                    console.error('Error loading data dictionaries:', result.error || result.message);
                }
            } catch (error) {
                dataDictionarySelect.innerHTML = '<option value="">-- Network Error --</option>';
                dataDictionaryStatus.textContent = `Network error loading dictionaries: ${error.message}`;
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600', 'text-gray-600');
                dataDictionaryStatus.classList.add('text-red-600');
                console.error('Network error loading data dictionaries:', error);
            }
        }

        /**
         * Event listener for loading a selected data dictionary's content.
         * Fetches the file data and parses it as an Excel workbook.
         */
        loadDataDictionaryBtn.addEventListener('click', async () => {
            const selectedFileId = dataDictionarySelect.value;
            if (!selectedFileId) {
                dataDictionaryStatus.textContent = 'Please select a dictionary to load.';
                dataDictionaryStatus.classList.remove('hidden', 'text-green-600');
                dataDictionaryStatus.classList.add('text-red-600');
                loadedDataDictionary = null; // Clear any previously loaded dictionary
                return;
            }

            dataDictionaryStatus.textContent = 'Loading dictionary content...';
            dataDictionaryStatus.classList.remove('hidden', 'text-red-600', 'text-green-600');
            dataDictionaryStatus.classList.add('text-gray-600');
            loadDataDictionaryBtn.disabled = true; // Disable button during load

            const token = localStorage.getItem('jwtToken');
            if (!token) {
                dataDictionaryStatus.textContent = 'Login required to load dictionary content.';
                dataDictionaryStatus.classList.add('text-red-600');
                loadDataDictionaryBtn.disabled = false;
                return;
            }

            try {
                // Fetch the binary content of the selected data dictionary file
                const response = await fetch(`/api/get-file?fileId=${selectedFileId}`, { // Use get-file to retrieve dictionary content
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json(); // Expecting JSON with fileData (base64)

                if (response.ok) {
                    // Decode base64 to binary string
                    const binaryString = atob(result.fileData);
                    // Convert binary string to Uint8Array
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    // Parse the binary Excel/CSV data using XLSX.js
                    const workbook = XLSX.read(bytes, { type: 'array', cellNF: true, cellDates: false });
                    
                    // Store the parsed workbook for later use by analyzeFile
                    loadedDataDictionary = workbook;
                    dataDiction
